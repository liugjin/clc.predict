// Generated by IcedCoffeeScript 108.0.13
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['clc.foundation', 'clc.foundation.data/app/models/monitoring/event-values-model', 'clc.foundation.data/app/models/monitoring/signal-values-model', 'clc.foundation.data/app/models/configuration/equipments-model', 'clc.foundation.data/app/models/configuration/stations-model', '../../../index-setting.json', 'moment', 'underscore'], function(base, event, signal, equipment, station, setting, moment, _) {
  var AutoDownloadService, exports;
  AutoDownloadService = (function(_super) {
    __extends(AutoDownloadService, _super);

    function AutoDownloadService(options) {
      this.options = options;
      this.publishData = __bind(this.publishData, this);
      this.getOneEquipInfo = __bind(this.getOneEquipInfo, this);
      this.downopcPerHour = __bind(this.downopcPerHour, this);
      this.getStreamData = __bind(this.getStreamData, this);
      this.downstreamPerHour = __bind(this.downstreamPerHour, this);
      this.writeCsv = __bind(this.writeCsv, this);
      AutoDownloadService.__super__.constructor.call(this, this.options);
      this.event = new event.EventValuesModel;
      this.equip = new equipment.EquipmentsModel;
      this.station = new station.StationsModel;
      this.signal = new signal.SignalValuesModel;
      this.fs = require("fs");
      this.path = require('path');
      this.request = require('request');
      this.jobopc = {};
      this.jobstream = {};
    }

    AutoDownloadService.prototype.initialize = function(callback) {
      AutoDownloadService.__super__.initialize.call(this, callback);
      return this.writeCsv();
    };

    AutoDownloadService.prototype.writeCsv = function() {
      return this.equip.query({
        user: setting.myproject.user,
        project: setting.myproject.project
      }, null, (function(_this) {
        return function(err, equips) {
          var equip, _i, _len, _results;
          equips = _.filter(equips, function(item) {
            return item.group === 'enable';
          });
          _this.enableEquips = equips;
          _results = [];
          for (_i = 0, _len = equips.length; _i < _len; _i++) {
            equip = equips[_i];
            _this.jobopc[equip.equipment] = null;
            _this.jobstream[equip.equipment] = null;
            _this.downopcPerHour(equip);
            _results.push(_this.downstreamPerHour(equip));
          }
          return _results;
        };
      })(this));
    };

    AutoDownloadService.prototype.downstreamPerHour = function(equip) {
      var pickChannels, queueChannels, rulestream, schedule, su, sustream;
      pickChannels = ['set-schedule-1', 'set-schedule-2', 'set-schedule-3', 'set-schedule-4', 'set-schedule-5', 'set-schedule-6', 'set-schedule-7'];
      queueChannels = ['queue-1-sample', 'queue-2-sample', 'queue-3-sample', 'queue-4-sample', 'queue-5-sample', 'queue-6-sample', 'queue-7-sample'];
      sustream = su = (_.find(equip.sampleUnits, (function(_this) {
        return function(i) {
          return i.id === 'sustream';
        };
      })(this))).value;
      schedule = require('node-schedule');
      rulestream = new schedule.RecurrenceRule();
      console.log('--每整点执行采数据控制--' + equip.equipment);
      rulestream.minute = 0;
      return this.jobstream[equip.equipment] = schedule.scheduleJob(rulestream, (function(_this) {
        return function() {
          var item, _i, _len;
          for (_i = 0, _len = pickChannels.length; _i < _len; _i++) {
            item = pickChannels[_i];
            _this.getStreamData(equip, item);
          }
          return setTimeout(function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = queueChannels.length; _j < _len1; _j++) {
              item = queueChannels[_j];
              _results.push(_this.getStreamData(equip, item));
            }
            return _results;
          }, 60000);
        };
      })(this));
    };

    AutoDownloadService.prototype.getStreamData = function(equip, controlId) {
      var topic1;
      topic1 = "command-values/" + equip.user + "/" + equip.project + "/" + equip.station + "/" + equip.equipment + "/" + controlId;
      console.log(topic1);
      return this.publishToMqtt(topic1, {
        user: equip.user,
        project: equip.project,
        station: equip.station,
        equipment: equip.equipment,
        command: controlId,
        parameters: [
          {
            key: "value",
            value: 1
          }
        ],
        phase: 'executing',
        startTime: new Date(),
        endTime: '',
        result: '',
        trigger: 'user',
        operator: setting.myproject.user,
        operatorName: ''
      });
    };

    AutoDownloadService.prototype.downopcPerHour = function(equip) {
      var ruleopc, schedule;
      schedule = require('node-schedule');
      ruleopc = new schedule.RecurrenceRule();
      ruleopc.minute = 1;
      console.log('--每整点零一分执行更新opc数据操作--' + equip.equipment);
      return this.jobopc[equip.equipment] = schedule.scheduleJob(ruleopc, (function(_this) {
        return function() {
          return _this.getOneEquipInfo(equip, function(d) {
            var createCsvWriter, csvWriter, data, fileName;
            console.log('---回调处理--');
            fileName = equip.station + "_" + equip.equipment + "_" + moment().format('YYYY-MM-DD-HH-mm-ss') + '.csv';
            createCsvWriter = require('csv-writer').createObjectCsvWriter;
            csvWriter = createCsvWriter({
              path: fileName,
              header: d.header
            });
            data = d.data;
            return csvWriter.writeRecords(data).then(function() {
              console.log(fileName + "-- was written successfully, 然后用request库把文件传到服务器指定地址");
              return setTimeout(function() {
                var csvpath, urlstr;
                csvpath = fileName;
                urlstr = "http://" + setting.host + "/resource/upload/predict/input/21012B1100293/" + fileName + "?author=" + setting.author + "&project=" + setting.myproject.project + "&token=" + setting.token;
                return _this.request.post({
                  url: urlstr,
                  json: true,
                  headers: {
                    "content-type": "application/json"
                  },
                  formData: {
                    file: _this.fs.createReadStream(csvpath)
                  }
                }, function(err, response, body) {
                  var pubName;
                  if (!err && response.statusCode === 200) {
                    pubName = ("http://" + setting.host + "/resource/upload/") + body.path;
                    console.log("文件上传成功 要发布的topic为" + d.su + "主题message地址为：" + pubName);
                    _this.fs.unlinkSync(fileName);
                    if (d.su) {
                      return _this.publishData(d.su, pubName);
                    }
                  }
                });
              }, 60000);
            });
          });
        };
      })(this));
    };

    AutoDownloadService.prototype.getOneEquipInfo = function(equip, callback) {
      var allDatas, cbdata, endTime, equipproperties, headers, index, item, startTime, su, _i, _j, _len, _len1, _opcsignals, _ref, _results;
      su = (_.find(equip.sampleUnits, (function(_this) {
        return function(i) {
          return i.id === 'su';
        };
      })(this))).value;
      equipproperties = {};
      _ref = equip.properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        equipproperties[item.id] = item.value;
      }
      _opcsignals = _.pluck(JSON.parse(equipproperties['_opcsignals']), 'signal');
      headers = [];
      allDatas = [];
      cbdata = {};
      index = 0;
      startTime = moment().startOf('hour');
      endTime = moment().startOf('hour').add(1, 'minute');
      _results = [];
      for (_j = 0, _len1 = _opcsignals.length; _j < _len1; _j++) {
        item = _opcsignals[_j];
        _results.push(this.signal.query({
          user: setting.myproject.user,
          project: setting.myproject.project,
          station: equip.station,
          equipment: equip.equipment,
          signal: item,
          timestamp: {
            "$gte": startTime,
            "$lt": endTime
          }
        }, null, (function(_this) {
          return function(err, signals) {
            var assign, d, data, datas, finalData, id, signalRecords, _k, _len2;
            if (err) {
              console.log(err);
            }
            if (signals.length) {
              console.log('-------' + signals[0].equipment + "----" + signals[0].signal + '-------');
            } else {
              if (!signals || (signals.length === 0)) {
                return console.log("此信号无数据记录");
              }
            }
            index++;
            id = equip.station + "_" + equip.equipment + "_" + signals[0].signal;
            headers.push({
              id: id,
              title: id
            });
            signalRecords = _.sortBy(signals, 'timestamp');
            finalData = _.pluck(signalRecords, 'value');
            datas = [];
            for (_k = 0, _len2 = finalData.length; _k < _len2; _k++) {
              d = finalData[_k];
              data = {};
              data[id] = d;
              datas.push(data);
            }
            if (allDatas.length === 0) {
              allDatas = JSON.parse(JSON.stringify(datas));
            } else {
              assign = function(target, args) {
                var j, key, source;
                if (target === null) {
                  return;
                }
                if (Object.assign) {
                  return Object.assign(target, args);
                } else {
                  _ = Object(target);
                  j = 1;
                  while (j < arguments.length) {
                    source = arguments[j];
                    if (source) {
                      for (key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          _[key] = source[key];
                        }
                      }
                    }
                    j++;
                  }
                  return _;
                }
              };
              allDatas = allDatas.map(function(o, index) {
                return assign(o, datas[index]);
              });
            }
            if (index === _opcsignals.length) {
              cbdata = {
                header: headers,
                data: allDatas,
                su: su
              };
              return typeof callback === "function" ? callback(cbdata) : void 0;
            }
          };
        })(this)));
      }
      return _results;
    };

    AutoDownloadService.prototype.publishData = function(su, url) {
      var topic0;
      if (su) {
        topic0 = "ssv/" + su + "/s-data-opc";
        console.log("发布opc数据topic为:" + topic0 + "--消息内容为:" + url);
        return this.publishToMqtt(topic0, url, {
          qos: 0,
          retain: true
        });
      }
    };

    return AutoDownloadService;

  })(base.MqttService);
  return exports = {
    AutoDownloadService: AutoDownloadService
  };
});
