// Generated by IcedCoffeeScript 108.0.13

/*
* File: stream-shock-curve-directive
* User: David
* Date: 2020/03/10
* Desc:
 */
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['../base-directive', 'text!./style.css', 'text!./view.html', 'underscore', "moment", "echarts"], function(base, css, view, _, moment, echarts) {
  var StreamShockCurveDirective, exports;
  StreamShockCurveDirective = (function(_super) {
    __extends(StreamShockCurveDirective, _super);

    function StreamShockCurveDirective($timeout, $window, $compile, $routeParams, commonService) {
      this.createOption = __bind(this.createOption, this);
      this.show = __bind(this.show, this);
      this.id = "stream-shock-curve";
      StreamShockCurveDirective.__super__.constructor.call(this, $timeout, $window, $compile, $routeParams, commonService);
    }

    StreamShockCurveDirective.prototype.setScope = function() {};

    StreamShockCurveDirective.prototype.setCSS = function() {
      return css;
    };

    StreamShockCurveDirective.prototype.setTemplate = function() {
      return view;
    };

    StreamShockCurveDirective.prototype.show = function(scope, element, attrs) {
      var colors, currentLegends, rABS, ySeriesDatas, _ref;
      rABS = false;
      colors = ['#FFD700', '#90D78A', '#1CAA9E', '#F9722C', '#FF085C'];
      scope.playFlag = false;
      scope.streamLegendList = [];
      currentLegends = [];
      ySeriesDatas = [];
      scope.equipSubscription = {};
      scope.interval1 = null;
      scope.chartOpts = {
        yData1MinAndMax: [0, 0]
      };
      scope.chartDatas = {
        yDatas: []
      };
      scope.getStreamSignalData = (function(_this) {
        return function() {
          var filter, strId, _ref;
          filter = {
            user: scope.project.model.user,
            project: scope.project.model.project,
            station: scope.equipment.model.station,
            equipment: scope.equipment.model.equipment,
            signal: scope.parameters.currentSignal + '-ttf'
          };
          strId = scope.equipment.key + "-" + filter.signal;
          if ((_ref = scope.equipSubscription[strId]) != null) {
            _ref.dispose();
          }
          return scope.equipSubscription[strId] = _this.commonService.signalLiveSession.subscribeValues(filter, function(err, signal) {
            var xhr;
            if (signal.message && signal.message.value) {
              scope.dataUrl = signal.message.value;
              xhr = new XMLHttpRequest();
              xhr.open('get', scope.dataUrl, true);
              xhr.responseType = 'arraybuffer';
              xhr.onload = function(e) {
                var data, testStr, wb;
                if (xhr.status === 200) {
                  data = new Uint8Array(xhr.response);
                  wb = XLSX.read(data, {
                    type: 'array'
                  });
                  testStr = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
                  scope.jsonToStringData(testStr);
                  return scope.InitChartOpt();
                }
              };
              return xhr.send();
            }
          });
        };
      })(this);
      if (scope.parameters.streamFlag) {
        scope.getStreamSignalData();
      } else {
        if ((_ref = scope.myChart) != null) {
          _ref.dispose();
        }
        scope.myChart = null;
      }
      scope.InitChartOpt = (function(_this) {
        return function() {
          var myChart, option;
          myChart = element.find("#ss-chart");
          scope.echart = echarts.init(myChart[0]);
          option = _this.createOption(scope.chartOpts);
          return scope.echart.setOption(option);
        };
      })(this);
      scope.chartShowAll = (function(_this) {
        return function() {
          clearInterval(scope.interval1);
          scope.playFlag = false;
          if (scope.echart && scope.chartOpts && scope.chartDatas.xData) {
            scope.chartOpts.yDatas = [];
            scope.chartOpts.yDatas.push(scope.chartDatas.yDatas[0], scope.chartDatas.yDatas[1], scope.chartDatas.yDatas[2]);
            currentLegends = scope.chartOpts.legends;
            return scope.reSetChartOpts(scope.chartOpts.yDatas);
          }
        };
      })(this);
      scope.chartPlayPause = (function(_this) {
        return function() {
          var i, item, _i, _len;
          if (!scope.playFlag) {
            if (scope.echart && scope.chartOpts && scope.chartDatas.xData) {
              if (ySeriesDatas.length === 0) {
                ySeriesDatas = [];
                for (i = _i = 0, _len = currentLegends.length; _i < _len; i = ++_i) {
                  item = currentLegends[i];
                  ySeriesDatas.push([]);
                }
              }
              scope.playFlag = true;
              return scope.interval1 = setInterval(function() {
                var j, _j, _k, _len1, _len2, _ref1;
                if (ySeriesDatas[0].length < scope.chartOpts.xData.length) {
                  i = 0;
                  while (i < 2) {
                    _ref1 = scope.chartOpts.yDatas;
                    for (j = _j = 0, _len1 = _ref1.length; _j < _len1; j = ++_j) {
                      item = _ref1[j];
                      ySeriesDatas[j].push(scope.chartOpts.yDatas[j][ySeriesDatas[j].length]);
                    }
                    i++;
                  }
                } else {
                  ySeriesDatas = [];
                  for (i = _k = 0, _len2 = currentLegends.length; _k < _len2; i = ++_k) {
                    item = currentLegends[i];
                    ySeriesDatas.push([]);
                  }
                }
                console.log(ySeriesDatas);
                return scope.reSetChartOpts(ySeriesDatas);
              }, 1000);
            }
          } else {
            clearInterval(scope.interval1);
            return scope.playFlag = false;
          }
        };
      })(this);
      scope.jsonToStringData = (function(_this) {
        return function(data) {
          var i, item, minAndMax, seriesName, xData, yData1, yData1MinAndMax, yData2, yData3, _i, _len;
          scope.chartOpts.legends = [];
          scope.chartOpts.yDatas = [];
          seriesName = ['A相电流', 'B相电流', 'C相电流'];
          scope.chartOpts.end = 5;
          scope.chartOpts.start = 0;
          if (Array.isArray(data)) {
            scope.chartOpts.legends = ['RMS Data', 'Amplitude of FFT Data', 'Phase Angle'];
            xData = [];
            yData1 = [];
            yData2 = [];
            yData3 = [];
            yData1MinAndMax = [];
            minAndMax = [];
            for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
              item = data[i];
              xData.push(i + 1);
              yData1.push(scope.checkIfNumber(item['RMS Data']));
              yData2.push(scope.checkIfNumber(item['Amplitude of FFT Data']));
              yData3.push(scope.checkIfNumber(item['Phase Angle']));
            }
            minAndMax.push(Math.min.apply(null, yData1), Math.max.apply(null, yData1));
            minAndMax.push(Math.min.apply(Math, yData2), Math.max.apply(Math, yData2));
            minAndMax.push(Math.min.apply(Math, yData3), Math.max.apply(Math, yData3));
            yData1MinAndMax.push(Math.min.apply(Math, minAndMax), Math.max.apply(Math, minAndMax));
            scope.chartOpts.yData1MinAndMax = yData1MinAndMax;
            scope.chartOpts.xData = xData;
            scope.chartOpts.yDatas.push(yData1, yData2, yData3);
            scope.chartOpts.title = scope.parameters.currentName + '数据分析图';
            scope.streamLegendList = _.map(scope.chartOpts.legends, function(d, i) {
              return {
                legend: d,
                name: d,
                index: i,
                check: true
              };
            });
            currentLegends = scope.chartOpts.legends;
            scope.chartDatas.xData = xData;
            scope.chartDatas.yDatas.push(yData1, yData2, yData3);
            return scope.$applyAsync();
          }
        };
      })(this);
      scope.fullscreen = function(element) {
        var el, exit;
        if (!element) {
          return;
        }
        if (typeof element === 'string') {
          el = angular.element(element);
          element = el[0];
        }
        exit = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
        if (exit) {
          if (document.exitFullscreen) {
            return document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            return document.webkitExitFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else if (document.mozExitFullScreen) {
            return document.mozExitFullScreen();
          } else if (document.msExitFullscreen) {
            return document.msExitFullscreen();
          }
        } else {
          if (element.requestFullscreen) {
            return element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            return element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else if (element.mozRequestFullScreen) {
            return element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            return element.msRequestFullscreen();
          }
        }
      };
      scope.checkIfNumber = (function(_this) {
        return function(val) {
          if (typeof val !== 'number') {
            return 0;
          }
          if (!isNaN(val)) {
            return val;
          } else {
            return 0;
          }
        };
      })(this);
      scope.selectLegend = (function(_this) {
        return function(leg, index) {
          var i, item, legendId, _i, _len, _ref1;
          legendId = _.indexOf(currentLegends, leg.legend);
          if (legendId === -1 && currentLegends.length < 3) {
            currentLegends.push(leg.legend);
          } else if (legendId !== -1 && currentLegends.length > 1) {
            currentLegends = _.filter(currentLegends, function(d) {
              return d !== leg.legend;
            });
            console.log(currentLegends);
          } else {
            _this.display('请选择1-3个数据项!');
            return;
          }
          scope.streamLegendList[index].check = !leg.check;
          scope.chartOpts.yDatas = [];
          _ref1 = scope.streamLegendList;
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            item = _ref1[i];
            if (item.check) {
              scope.chartOpts.yDatas.push(scope.chartDatas.yDatas[i]);
            }
          }
          ySeriesDatas = scope.chartOpts.yDatas;
          return scope.reSetChartOpts(scope.chartOpts.yDatas);
        };
      })(this);
      scope.reSetChartOpts = (function(_this) {
        return function(yDatas) {
          var i, item, series, visualMap, _i, _len;
          series = [];
          visualMap = [];
          for (i = _i = 0, _len = yDatas.length; _i < _len; i = ++_i) {
            item = yDatas[i];
            series.push({
              name: currentLegends[i],
              data: item
            });
            visualMap.push({
              pieces: [
                {
                  gt: 0,
                  lte: 100,
                  color: colors[i % colors.length]
                }
              ],
              seriesIndex: i,
              outOfRange: {
                color: 'red'
              }
            });
          }
          scope.echart.setOption({
            series: [
              {
                data: null
              }, {
                data: null
              }, {
                data: null
              }
            ]
          });
          return scope.echart.setOption({
            legend: {
              data: currentLegends
            },
            visualMap: visualMap,
            series: series
          });
        };
      })(this);
      scope.hidemodal = function() {
        return $('#stream-predict-modal').modal('close');
      };
      scope.openModal = function() {
        return $('#stream-predict-modal').modal('open');
      };
      scope.resize = (function(_this) {
        return function() {
          return _this.$timeout(function() {
            var _ref1;
            return (_ref1 = scope.myChart) != null ? _ref1.resize() : void 0;
          }, 100);
        };
      })(this);
      scope.signalDataArr = [];
      scope.submitDatas = {
        currentSignal: '',
        predictNum: 0,
        predictText: ''
      };
      scope.equipment.loadSignals(null, (function(_this) {
        return function(err, signals) {
          var sig, signalValue, _i, _len, _results;
          if (signals) {
            _results = [];
            for (_i = 0, _len = signals.length; _i < _len; _i++) {
              sig = signals[_i];
              if (sig.model.type === scope.equipment.model.type) {
                if (sig.model.template === "base-" + scope.equipment.model.type && sig.model.signal !== "device-flag") {
                  signalValue = {};
                  signalValue.name = sig.model.name;
                  signalValue.signalID = sig.model.signal;
                  signalValue.passId = sig.model.expression.variables[0].value;
                  signalValue.check = false;
                  scope.signalDataArr.push(signalValue);
                  _results.push(scope.submitDatas.currentSignal = scope.signalDataArr[0]);
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        };
      })(this));
      scope.selectStreamSig = (function(_this) {
        return function(type, index) {
          return scope.submitDatas.currentSignal = type;
        };
      })(this);
      scope.submitMessage = (function(_this) {
        return function() {
          var channel1, channel2Data, i, str, su, sus, _i, _len;
          if (Number(scope.submitDatas.predictNum) > 100 || Number(scope.submitDatas.predictNum) < 0) {
            _this.display('预测值为0~100之间!');
          } else {
            channel2Data = {};
            console.log(scope);
            channel1 = scope.submitDatas.currentSignal.passId.split('/')[1];
            channel2Data.mchannel = channel1;
            channel2Data.mvalue = Number(scope.submitDatas.predictNum);
            channel2Data.editor = scope.project.model.userName;
            channel2Data.psignal = scope.submitDatas.currentSignal.signalID;
            channel2Data.url = scope.dataUrl;
            channel2Data.desc = scope.submitDatas.predictText;
            str = Number(scope.submitDatas.predictNum);
            sus = scope.equipment.model.sampleUnits;
            su = '';
            for (_i = 0, _len = sus.length; _i < _len; _i++) {
              i = sus[_i];
              if (i.id === 'sustream') {
                su = i.value;
              }
            }
            return $.post("manualControl", {
              su: su,
              channel1: channel1,
              channel1data: str,
              channel2: "manual-describe",
              channel2data: channel2Data
            }).then(function(response) {
              console.log(response);
              if (response.result === 1 || response.data.result === 1) {
                _this.display('信息反馈成功!');
                scope.submitDatas.predictNum = 0;
                scope.submitDatas.predictText = '';
                return scope.hidemodal();
              } else {
                return _this.display('信息反馈失败!');
              }
            });
          }
        };
      })(this);
      return window.addEventListener('resize', scope.resize);
    };

    StreamShockCurveDirective.prototype.createOption = function(opts) {
      var colors, index, item, option, series, visualMap, _i, _len, _ref;
      colors = ['#FFD700', '#90D78A', '#1CAA9E', '#F9722C', '#FF085C'];
      series = [];
      visualMap = [];
      _ref = opts.yDatas;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        item = _ref[index];
        series.push({
          name: opts.legends[index],
          type: 'line',
          symbol: "none",
          lineStyle: {
            width: 2
          },
          smooth: true,
          data: item
        });
        visualMap.push({
          top: 20,
          right: 10,
          textStyle: {
            color: '#fff'
          },
          pieces: [
            {
              gt: 0,
              lte: 100,
              color: colors[index % colors.length]
            }
          ],
          seriesIndex: index,
          outOfRange: {
            color: 'red'
          }
        });
      }
      option = {
        animation: false,
        title: {
          text: opts.title,
          textStyle: {
            color: '#fff'
          },
          left: 'center',
          top: 0
        },
        tooltip: {
          show: true,
          trigger: "axis",
          axisPointer: {
            type: 'cross'
          }
        },
        legend: {
          show: true,
          orient: "horizontal",
          bottom: 30,
          textStyle: {
            fontSize: 14,
            color: "#FFFFFF"
          },
          data: opts.legends
        },
        toolbox: {
          show: true,
          right: 0,
          feature: {
            dataZoom: {
              show: false
            },
            dataView: {
              show: false
            },
            magicType: {
              type: ['line', 'bar']
            },
            restore: {
              show: false
            },
            saveAsImage: {
              show: false
            }
          }
        },
        visualMap: visualMap,
        dataZoom: [
          {
            type: 'inside',
            realtime: true,
            start: opts.start,
            end: opts.end,
            xAxisIndex: [0]
          }, {
            show: true,
            realtime: true,
            type: 'slider',
            dataBackground: {
              lineStyle: {
                width: 3,
                color: 'rgb(9,175,211)'
              }
            },
            textStyle: {
              fontSize: 14,
              color: "#FFFFFF"
            },
            fillerColor: "rgba(167,183,204,0.4)",
            bottom: 0,
            xAxisIndex: [0]
          }
        ],
        xAxis: [
          {
            data: opts.xData,
            type: 'category',
            boundaryGap: false,
            nameLocation: "middle",
            axisLine: {
              onZero: false,
              lineStyle: {
                color: "#204BAD"
              }
            },
            axisLabel: {
              show: false,
              textStyle: {
                color: "#fff"
              }
            }
          }
        ],
        yAxis: [
          {
            name: '震动数据',
            type: 'value',
            axisLine: {
              lineStyle: {
                color: "#204BAD"
              }
            },
            axisLabel: {
              textStyle: {
                color: "#fff"
              }
            },
            splitLine: {
              show: false
            }
          }
        ],
        series: series
      };
      return option;
    };

    StreamShockCurveDirective.prototype.resize = function(scope) {
      var _ref;
      return (_ref = scope.myChart) != null ? _ref.resize() : void 0;
    };

    StreamShockCurveDirective.prototype.dispose = function(scope) {
      var key, value, _ref, _ref1;
      if ((_ref = scope.myChart) != null) {
        _ref.dispose();
      }
      _ref1 = scope.equipSubscription;
      for (key in _ref1) {
        value = _ref1[key];
        if (value != null) {
          value.dispose();
        }
      }
      scope.myChart = null;
      scope.chartOpts = null;
      scope.chartDatas = null;
      return clearInterval(scope.interval1);
    };

    return StreamShockCurveDirective;

  })(base.BaseDirective);
  return exports = {
    StreamShockCurveDirective: StreamShockCurveDirective
  };
});
