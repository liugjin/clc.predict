// Generated by IcedCoffeeScript 108.0.13

/*
* File: stream-compare-directive
* User: David
* Date: 2020/04/01
* Desc:
 */
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['../base-directive', 'text!./style.css', 'text!./view.html', 'underscore', "moment", "echarts"], function(base, css, view, _, moment, echarts) {
  var StreamCompareDirective, exports;
  StreamCompareDirective = (function(_super) {
    __extends(StreamCompareDirective, _super);

    function StreamCompareDirective($timeout, $window, $compile, $routeParams, commonService) {
      this.createOption = __bind(this.createOption, this);
      this.show = __bind(this.show, this);
      this.id = "stream-compare";
      StreamCompareDirective.__super__.constructor.call(this, $timeout, $window, $compile, $routeParams, commonService);
    }

    StreamCompareDirective.prototype.setScope = function() {};

    StreamCompareDirective.prototype.setCSS = function() {
      return css;
    };

    StreamCompareDirective.prototype.setTemplate = function() {
      return view;
    };

    StreamCompareDirective.prototype.show = function(scope, element, attrs) {
      var appendOriginStreamData, appendStreamData, checkFilter, createOriginOption, dataAnalysis1, dataAnalysis3, getStreamDataOrigin, getStreamSignalData, jsonToStringData, loadEquipmentAndSignals, originStreamData2, queryStreamSignalRecords, reSetChartOpts, reSetOringinChartOpts, _ref, _ref1;
      scope.previousStreamList = [];
      scope.currentItem = null;
      scope.selectSignals = [];
      scope.chartOpts1 = {};
      scope.chartDatas1 = {};
      scope.chartOpts2 = {};
      scope.chartDatas2 = {};
      scope.equipSubscription = {};
      scope.chartOpts1.legends = [];
      scope.chartOpts1.yDatas = [];
      scope.chartOpts2.legends = [];
      scope.chartOpts2.yDatas = [];
      scope.playFlag = false;
      scope.compareFlag = 1;
      scope.streamType = 1;
      scope.dataNumFlag = 1;
      scope.urls = [];
      scope.interval1 = null;
      scope.query = {
        startTime: '',
        endTime: ''
      };
      scope.selectSignal = function(sig) {
        var _ref, _ref1, _ref2;
        scope.selectSignals = [sig];
        if ((_ref = scope.echart1) != null) {
          _ref.dispose();
        }
        if ((_ref1 = scope.echart2) != null) {
          _ref1.dispose();
        }
        if ((_ref2 = scope.mychart) != null) {
          _ref2.dispose();
        }
        scope.compareFlag = 1;
        $('#mysigs').hide();
        clearInterval(scope.interval1);
        queryStreamSignalRecords();
        return scope.queryStreamData();
      };
      scope.dataFlag = false;
      if ((_ref = scope.timeSubscription) != null) {
        _ref.dispose();
      }
      scope.timeSubscription = this.commonService.subscribeEventBus('time', (function(_this) {
        return function(d) {
          scope.query.startTime = moment(d.message.startTime).startOf('day');
          scope.query.endTime = moment(d.message.endTime).endOf('day');
          console.log('时间-----');
          return queryStreamSignalRecords();
        };
      })(this));
      if ((_ref1 = scope.selectEquipSubscription) != null) {
        _ref1.dispose();
      }
      scope.selectEquipSubscription = this.commonService.subscribeEventBus('selectEquip', (function(_this) {
        return function(msg) {
          scope.multiflag = false;
          scope.selectedEquips = [msg.message];
          scope.compareFlag = 1;
          clearInterval(scope.interval1);
          scope.selectedEquips = _.filter(scope.selectedEquips, function(item) {
            return item.level === 'equipment';
          });
          return loadEquipmentAndSignals(scope.selectedEquips, function(data) {
            var _ref2, _ref3, _ref4;
            scope.selectSignals = [scope.signals[0]];
            if (scope.selectSignals.length) {
              scope.dataFlag = false;
              if ((_ref2 = scope.echart1) != null) {
                _ref2.dispose();
              }
              if ((_ref3 = scope.echart2) != null) {
                _ref3.dispose();
              }
              if ((_ref4 = scope.mychart) != null) {
                _ref4.dispose();
              }
              console.log('选择设备');
              queryStreamSignalRecords();
              return scope.queryStreamData();
            }
          });
        };
      })(this));
      queryStreamSignalRecords = (function(_this) {
        return function() {
          var data, filter;
          if (checkFilter()) {
            return;
          }
          filter = {};
          filter["$or"] = _.map(scope.selectedEquips, function(equip) {
            return {
              station: equip.station,
              equipment: equip.id
            };
          });
          filter.startTime = scope.query.startTime;
          filter.endTime = scope.query.endTime;
          filter.user = scope.selectSignals[0].model.user;
          filter.project = scope.selectSignals[0].model.project;
          filter.signal = scope.selectSignals[0].model.signal;
          filter.mode = {
            "$nin": ["event"]
          };
          data = {
            filter: filter,
            paging: null,
            sorting: {
              station: 1,
              equipment: 1,
              timestamp: 1
            }
          };
          return _this.commonService.reportingService.querySignalRecords(data, function(err, records) {
            var record, str, _i, _len;
            if (err) {
              return console.log('err:', err);
            }
            console.log(records);
            for (_i = 0, _len = records.length; _i < _len; _i++) {
              record = records[_i];
              str = '第' + moment(record.timestamp).format("YYYY-MM-DD HH:mm:ss") + '期';
              record.timeName = str;
            }
            scope.previousStreamList = records;
            return scope.currentPreviousStream = records[0];
          });
        };
      })(this);
      scope.streamDataComparing = (function(_this) {
        return function() {
          var url, xhr;
          url = scope.currentPreviousStream.value;
          scope.collectTime2 = moment(scope.currentPreviousStream.timestamp).format("YYYY-MM-DD HH:mm:ss");
          if (scope.currentPreviousStream) {
            scope.compareFlag = 2;
            if (scope.streamType === 1) {
              return originStreamData2(url, 2);
            } else if (scope.streamType === 2) {
              xhr = new XMLHttpRequest();
              xhr.open('get', url, true);
              xhr.responseType = 'arraybuffer';
              xhr.onload = function(e) {
                var data, testStr, wb;
                scope.$root.loading = true;
                if (xhr.status === 200) {
                  data = new Uint8Array(xhr.response);
                  wb = XLSX.read(data, {
                    type: 'array'
                  });
                  testStr = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
                  return jsonToStringData(testStr, 2);
                }
              };
              return xhr.send();
            }
          } else {
            return _this.display("请选择流数据往期号");
          }
        };
      })(this);
      loadEquipmentAndSignals = (function(_this) {
        return function(equipments, callback) {
          var equip, equipmentId, station, stationId, _i, _len, _results;
          scope.equipments = [];
          scope.signals = [];
          _results = [];
          for (_i = 0, _len = equipments.length; _i < _len; _i++) {
            equip = equipments[_i];
            if (equip.level === 'equipment') {
              stationId = equip.station;
              equipmentId = equip.id;
              _results.push((function() {
                var _j, _len1, _ref2, _results1;
                _ref2 = scope.project.stations.items;
                _results1 = [];
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                  station = _ref2[_j];
                  if ((station != null ? station.model.station : void 0) === stationId) {
                    _results1.push(this.commonService.loadEquipmentById(station, equipmentId, (function(_this) {
                      return function(err, equipment) {
                        if (err) {
                          return console.log("err:", err);
                        }
                        scope.equipments.push(equipment);
                        return equipment.loadSignals(null, function(err, model) {
                          var finalData, streamSignals;
                          if (err) {
                            return console.log("err:", err);
                          }
                          finalData = _.uniq(model);
                          streamSignals = _.filter(finalData, function(sig) {
                            var _ref3, _ref4;
                            return sig.model.visible === true && ((_ref3 = sig.model.dataType) === 'json' || _ref3 === 'string') && ((_ref4 = sig.model.group) === 'stream' || _ref4 === 'ttf');
                          });
                          scope.signals = _.filter(streamSignals, function(sig) {
                            var _ref3;
                            return (_ref3 = sig.model.signal) !== 'manual-describe' && _ref3 !== 's-data-result';
                          });
                          return typeof callback === "function" ? callback(true) : void 0;
                        });
                      };
                    })(this)));
                  } else {
                    _results1.push(void 0);
                  }
                }
                return _results1;
              }).call(_this));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this);
      scope.selectCurrentStream = (function(_this) {
        return function(item) {
          return scope.currentPreviousStream = item;
        };
      })(this);
      checkFilter = function() {
        if (!scope.selectedEquips || (!scope.selectedEquips.length)) {
          M.toast({
            html: '请选择设备'
          });
          return true;
        }
        if (moment(scope.query.startTime).isAfter(moment(scope.query.endTime))) {
          M.toast({
            html: '开始时间大于结束时间！'
          });
          return true;
        }
        return false;
      };
      scope.filterSig = (function(_this) {
        return function() {
          return function(equipment) {
            var _ref2;
            if ((_ref2 = equipment.model.dataType) === "int" || _ref2 === "float" || _ref2 === "enum" || _ref2 === "string") {
              return true;
            }
            return false;
          };
        };
      })(this);
      scope.selectSeriesData = (function(_this) {
        return function(abc, index) {
          var abcIndex, legendIndex;
          clearInterval(scope.interval1);
          legendIndex = Number(scope.chartOpts1.currentLegends.index);
          abcIndex = Number(index + 1);
          scope.currentDisplayList = scope.streamLegendList[index];
          scope.chartOpts1.currentAbcSeries = scope.chartOpts2.currentAbcSeries = scope.abcSeriesList[index];
          scope.chartOpts1.currentLegends = scope.chartOpts2.currentLegends = scope.currentDisplayList[legendIndex];
          scope.chartOpts1.yData1 = scope.chartDatas1['data' + abcIndex].yData1[legendIndex];
          scope.chartOpts1.yData2 = scope.chartDatas1['data' + abcIndex].yData2[legendIndex];
          scope.currentMinAndMax[0] = scope.maxAndMins['minAndMax' + abcIndex].yData1MinAndMax[legendIndex];
          scope.currentMinAndMax[1] = scope.maxAndMins['minAndMax' + abcIndex].yData2MinAndMax[legendIndex];
          if (scope.compareFlag === 2) {
            scope.chartOpts2.yData1 = scope.chartDatas2['data' + abcIndex].yData1[legendIndex];
            scope.chartOpts2.yData2 = scope.chartDatas2['data' + abcIndex].yData2[legendIndex];
            scope.compareMinAndMax[0] = scope.maxAndMins2['minAndMax' + abcIndex].yData1MinAndMax[legendIndex];
            scope.compareMinAndMax[1] = scope.maxAndMins2['minAndMax' + abcIndex].yData2MinAndMax[legendIndex];
          }
          if (scope.chartOpts2.yData1 && scope.compareFlag === 2) {
            return appendStreamData();
          } else {
            return reSetChartOpts(scope.chartOpts1);
          }
        };
      })(this);
      scope.selectLegend = (function(_this) {
        return function(leg, index) {
          var abcIndex;
          clearInterval(scope.interval1);
          scope.chartOpts1.currentLegends = scope.chartOpts2.currentLegends = scope.currentDisplayList[index];
          if (scope.chartOpts1.currentAbcSeries) {
            abcIndex = Number(scope.chartOpts1.currentAbcSeries.index + 1);
            scope.chartOpts1.yData1 = scope.chartDatas1['data' + abcIndex].yData1[index];
            scope.chartOpts1.yData2 = scope.chartDatas1['data' + abcIndex].yData2[index];
            scope.currentMinAndMax[0] = scope.maxAndMins['minAndMax' + abcIndex].yData1MinAndMax[index];
            scope.currentMinAndMax[1] = scope.maxAndMins['minAndMax' + abcIndex].yData2MinAndMax[index];
            if (scope.compareFlag === 2) {
              scope.chartOpts2.yData1 = scope.chartDatas2['data' + abcIndex].yData1[index];
              scope.chartOpts2.yData2 = scope.chartDatas2['data' + abcIndex].yData2[index];
              scope.compareMinAndMax[0] = scope.maxAndMins2['minAndMax' + abcIndex].yData1MinAndMax[index];
              scope.compareMinAndMax[1] = scope.maxAndMins2['minAndMax' + abcIndex].yData2MinAndMax[index];
            }
          } else {
            scope.chartOpts1.yData1 = scope.chartDatas1.yData1[index];
            scope.chartOpts1.yData2 = scope.chartDatas1.yData2[index];
            scope.currentMinAndMax[0] = scope.maxAndMins.yData1MinAndMax[index];
            scope.currentMinAndMax[1] = scope.maxAndMins.yData2MinAndMax[index];
            if (scope.compareFlag === 2) {
              scope.chartOpts2.yData1 = scope.chartDatas2.yData1[index];
              scope.chartOpts2.yData2 = scope.chartDatas2.yData2[index];
              scope.compareMinAndMax[0] = scope.maxAndMins.yData1MinAndMax[index];
              scope.compareMinAndMax[1] = scope.maxAndMins.yData2MinAndMax[index];
            }
          }
          if (scope.chartOpts2.yData1 && scope.compareFlag === 2) {
            return appendStreamData();
          } else {
            return reSetChartOpts(scope.chartOpts1);
          }
        };
      })(this);
      scope.queryStreamData = (function(_this) {
        return function(page, pageItems) {
          var signal, str;
          if (page == null) {
            page = 1;
          }
          if (pageItems == null) {
            pageItems = 10;
          }
          if (checkFilter()) {
            return;
          }
          if (scope.selectSignals[0]) {
            signal = scope.selectSignals[0].model.signal;
            str = signal.split('-');
            scope.streamLegendList = [];
            if (str.length === 4 && str[3] === 'ttf') {
              scope.streamType = 2;
              scope.currentMinAndMax = [[0, 0], [0, 0]];
              scope.compareMinAndMax = [[0, 0], [0, 0]];
              scope.chartOpts1.normalDatas = [[-20000000, 20000000], [0, 200]];
              scope.chartOpts1.end = 10;
              scope.chartOpts1.start = 0;
              scope.abcSeriesList = [];
              scope.chartOpts1.legends = [];
              scope.maxAndMins = {};
              scope.maxAndMins2 = {};
              scope.streamLegendList = [];
              scope.currentDisplayList = [];
              scope.chartOpts1.title1 = scope.selectSignals[0].model.name + '时域图';
              scope.chartOpts1.title2 = scope.selectSignals[0].model.name + '频域图';
              return getStreamSignalData(1);
            } else {
              scope.streamType = 1;
              if (signal === 's-data-7' || signal === 's-data-7-ttf') {
                scope.legendList = ['A相电流', 'B相电流', 'C相电流'];
              } else if (signal === 's-data-5' || signal === 's-data-6') {
                scope.legendList = ['X轴震动', 'Y轴震动', 'Z轴震动'];
              } else {
                scope.legendList = [scope.selectSignals[0].model.name];
              }
              scope.chartOpts1.legends = scope.legendList;
              scope.chartOpts1.end = 2;
              scope.chartOpts1.start = 0;
              scope.currentMinAndMax = [0, 0];
              scope.compareMinAndMax = [0, 0];
              return getStreamDataOrigin(1);
            }
          }
        };
      })(this);
      getStreamSignalData = (function(_this) {
        return function(dindex) {
          var filter, strId, _ref2;
          filter = {
            user: scope.project.model.user,
            project: scope.project.model.project,
            station: scope.selectedEquips[0].station,
            equipment: scope.selectedEquips[0].id,
            signal: scope.selectSignals[0].model.signal
          };
          strId = scope.selectedEquips[0].station + "-" + scope.selectedEquips[0].id + "-" + scope.selectSignals[0].model.signal;
          if ((_ref2 = scope.equipSubscription[strId]) != null) {
            _ref2.dispose();
          }
          return scope.equipSubscription[strId] = _this.commonService.signalLiveSession.subscribeValues(filter, function(err, signal) {
            var xhr;
            if (signal.message && signal.message.value) {
              scope.collectTime = moment(signal.message.timestamp).format("YYYY-MM-DD HH:mm:ss");
              scope.dataFlag = true;
              scope.$root.loading = true;
              scope.dataUrl = signal.message.value;
              xhr = new XMLHttpRequest();
              xhr.open('get', scope.dataUrl, true);
              xhr.responseType = 'arraybuffer';
              xhr.onload = function(e) {
                var data, testStr, wb;
                scope.$root.loading = true;
                if (xhr.status === 200) {
                  data = new Uint8Array(xhr.response);
                  wb = XLSX.read(data, {
                    type: 'array'
                  });
                  testStr = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
                  return jsonToStringData(testStr, dindex);
                }
              };
              return xhr.send();
            }
          });
        };
      })(this);
      jsonToStringData = (function(_this) {
        return function(data, dindex) {
          var i, j, k, keyData, name, name1, name2, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4;
          if (Array.isArray(data)) {
            scope.streamLegendList = [];
            scope['chartOpts' + dindex].legends = [];
            keyData = data[0];
            for (j in keyData) {
              k = keyData[j];
              scope['chartOpts' + dindex].legends.push(j);
            }
            if (scope['chartOpts' + dindex].legends.length === 21) {
              scope['chartOpts' + dindex].legends.pop();
              scope['chartDatas' + dindex].data1 = {
                yData1: [[], [], []],
                yData2: [[], [], []]
              };
              scope['chartDatas' + dindex].data2 = {
                yData1: [[], [], []],
                yData2: [[], [], []]
              };
              scope['chartDatas' + dindex].data3 = {
                yData1: [[], [], []],
                yData2: [[], [], []]
              };
              scope['chartOpts' + dindex].legends.splice(6, 1);
              scope['chartOpts' + dindex].legends.splice(12, 1);
              scope.dataNumFlag = 3;
              _ref2 = [0, 1, 2];
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                j = _ref2[_i];
                scope.streamLegendList.push([]);
                _ref3 = [0, 1, 2];
                for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                  i = _ref3[_j];
                  name1 = scope['chartOpts' + dindex].legends[i + j * 6];
                  name2 = scope['chartOpts' + dindex].legends[i + j * 6 + 3];
                  name = name1 + ',' + name2;
                  scope.streamLegendList[j].push({
                    legend1: name1,
                    legend2: name2,
                    name: name,
                    index: i,
                    optindex: j
                  });
                }
              }
              return dataAnalysis3(data, dindex);
            } else if (scope['chartOpts' + dindex].legends.length === 7) {
              scope['chartOpts' + dindex].legends.pop();
              scope['chartDatas' + dindex].yData1 = [[], [], []];
              scope['chartDatas' + dindex].yData2 = [[], [], []];
              scope.dataNumFlag = 1;
              _ref4 = [0, 1, 2];
              for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                i = _ref4[_k];
                name1 = scope['chartOpts' + dindex].legends[i];
                name2 = scope['chartOpts' + dindex].legends[i + 3];
                name = name1 + ',' + name2;
                scope.streamLegendList.push({
                  legend1: name1,
                  legend2: name2,
                  name: name,
                  index: i
                });
              }
              return dataAnalysis1(data, dindex);
            }
          }
        };
      })(this);
      dataAnalysis1 = (function(_this) {
        return function(data, dindex) {
          var i, item, xData, yData1MinAndMax, yData2MinAndMax, _i, _len;
          xData = [];
          yData1MinAndMax = [[], [], []];
          yData2MinAndMax = [[], [], []];
          scope['chartOpts' + dindex].normalDatas = [[-20000000, 20000000], [0, 50]];
          for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
            item = data[i];
            xData.push(i + 1);
            scope['chartDatas' + dindex].yData1[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[0]]));
            scope['chartDatas' + dindex].yData1[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[1]]));
            scope['chartDatas' + dindex].yData1[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[2]]));
            scope['chartDatas' + dindex].yData2[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[3]]));
            scope['chartDatas' + dindex].yData2[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[4]]));
            scope['chartDatas' + dindex].yData2[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[5]]));
          }
          scope['chartOpts' + dindex].xData = xData;
          if (scope['chartOpts' + dindex].currentLegends) {
            scope['chartOpts' + dindex].currentLegends = scope.streamLegendList[scope.chartOpts1.currentLegends.index];
          } else {
            scope['chartOpts' + dindex].currentLegends = scope.streamLegendList[0];
          }
          scope['chartOpts' + dindex].yData1 = scope['chartDatas' + dindex].yData1[scope.chartOpts1.currentLegends.index];
          scope['chartOpts' + dindex].yData2 = scope['chartDatas' + dindex].yData2[scope.chartOpts1.currentLegends.index];
          scope.currentDisplayList = scope.streamLegendList;
          scope['chartDatas' + dindex].xData = xData;
          scope.$root.loading = false;
          if (dindex === 1) {
            scope.InitChartOpt(dindex);
          } else if (dindex === 2) {
            appendStreamData(1);
          }
          yData1MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].yData1[0]), Math.max.apply(Math, scope['chartDatas' + dindex].yData1[0]));
          yData1MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].yData1[1]), Math.max.apply(Math, scope['chartDatas' + dindex].yData1[1]));
          yData1MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].yData1[2]), Math.max.apply(Math, scope['chartDatas' + dindex].yData1[2]));
          yData2MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].yData2[0]), Math.max.apply(Math, scope['chartDatas' + dindex].yData2[0]));
          yData2MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].yData2[1]), Math.max.apply(Math, scope['chartDatas' + dindex].yData2[1]));
          yData2MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].yData2[2]), Math.max.apply(Math, scope['chartDatas' + dindex].yData2[2]));
          if (dindex === 1) {
            scope.maxAndMins.yData1MinAndMax = yData1MinAndMax;
            scope.maxAndMins.yData2MinAndMax = yData2MinAndMax;
            scope.currentMinAndMax[0] = yData1MinAndMax[scope.chartOpts1.currentLegends.index];
            scope.currentMinAndMax[1] = yData2MinAndMax[scope.chartOpts1.currentLegends.index];
          } else if (dindex === 2) {
            scope.maxAndMins.compareyData1MinAndMax = yData1MinAndMax;
            scope.maxAndMins.compareyData2MinAndMax = yData2MinAndMax;
            scope.compareMinAndMax[0] = yData1MinAndMax[scope.chartOpts1.currentLegends.index];
            scope.compareMinAndMax[1] = yData2MinAndMax[scope.chartOpts1.currentLegends.index];
          }
          return scope.$applyAsync();
        };
      })(this);
      dataAnalysis3 = (function(_this) {
        return function(data, dindex) {
          var i, item, minAndMax1, minAndMax2, minAndMax3, num1, num2, seriesSelect, signal, xData, _i, _len;
          xData = [];
          signal = scope.selectSignals[0].model.signal;
          if (signal === 's-data-7-ttf') {
            seriesSelect = ['A相电流', 'B相电流', 'C相电流'];
          } else if (signal === 's-data-5-ttf' || signal === 's-data-6-ttf') {
            seriesSelect = ['X轴震动', 'Y轴震动', 'Z轴震动'];
          }
          minAndMax1 = {
            yData1MinAndMax: [[], [], []],
            yData2MinAndMax: [[], [], []]
          };
          minAndMax2 = {
            yData1MinAndMax: [[], [], []],
            yData2MinAndMax: [[], [], []]
          };
          minAndMax3 = {
            yData1MinAndMax: [[], [], []],
            yData2MinAndMax: [[], [], []]
          };
          scope.abcSeriesList = _.map(seriesSelect, function(d, i) {
            return {
              legend: d,
              name: d,
              index: i
            };
          });
          if (scope.chartOpts1.currentAbcSeries) {
            scope['chartOpts' + dindex].currentAbcSeries = scope.abcSeriesList[scope.chartOpts1.currentAbcSeries.index];
            scope.currentDisplayList = scope.streamLegendList[scope.chartOpts1.currentAbcSeries.index];
          } else {
            scope['chartOpts' + dindex].currentAbcSeries = scope.abcSeriesList[0];
            scope.currentDisplayList = scope.streamLegendList[0];
          }
          if (scope.chartOpts1.currentLegends) {
            scope['chartOpts' + dindex].currentLegends = scope.currentDisplayList[scope.chartOpts1.currentLegends.index];
          } else {
            scope['chartOpts' + dindex].currentLegends = scope.currentDisplayList[0];
          }
          for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
            item = data[i];
            xData.push(i + 1);
            scope['chartDatas' + dindex].data1.yData1[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[0]]));
            scope['chartDatas' + dindex].data1.yData1[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[1]]));
            scope['chartDatas' + dindex].data1.yData1[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[2]]));
            scope['chartDatas' + dindex].data1.yData2[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[3]]));
            scope['chartDatas' + dindex].data1.yData2[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[4]]));
            scope['chartDatas' + dindex].data1.yData2[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[5]]));
            scope['chartDatas' + dindex].data2.yData1[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[6]]));
            scope['chartDatas' + dindex].data2.yData1[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[7]]));
            scope['chartDatas' + dindex].data2.yData1[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[8]]));
            scope['chartDatas' + dindex].data2.yData2[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[9]]));
            scope['chartDatas' + dindex].data2.yData2[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[10]]));
            scope['chartDatas' + dindex].data2.yData2[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[11]]));
            scope['chartDatas' + dindex].data3.yData1[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[12]]));
            scope['chartDatas' + dindex].data3.yData1[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[13]]));
            scope['chartDatas' + dindex].data3.yData1[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[14]]));
            scope['chartDatas' + dindex].data3.yData2[0].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[15]]));
            scope['chartDatas' + dindex].data3.yData2[1].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[16]]));
            scope['chartDatas' + dindex].data3.yData2[2].push(scope.checkIfNumber(item[scope['chartOpts' + dindex].legends[17]]));
          }
          scope['chartOpts' + dindex].xData = xData;
          if (scope.compareFlag === 1) {
            scope['chartOpts' + dindex].yData1 = scope['chartDatas' + dindex].data1.yData1[0];
            scope['chartOpts' + dindex].yData2 = scope['chartDatas' + dindex].data1.yData2[0];
          } else if (scope.compareFlag === 2) {
            num1 = scope.chartOpts1.currentAbcSeries.index + 1;
            num2 = scope.chartOpts1.currentLegends.index;
            scope['chartOpts' + dindex].yData1 = scope['chartDatas' + dindex]['data' + num1].yData1[num2];
            scope['chartOpts' + dindex].yData2 = scope['chartDatas' + dindex]['data' + num1].yData2[num2];
          }
          scope['chartDatas' + dindex].xData = xData;
          scope.$root.loading = false;
          if (dindex === 1) {
            scope.InitChartOpt(dindex);
          } else if (dindex === 2) {
            appendStreamData(dindex);
          }
          minAndMax1.yData1MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].data1.yData1[0]), Math.max.apply(Math, scope['chartDatas' + dindex].data1.yData1[0]));
          minAndMax1.yData1MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].data1.yData1[1]), Math.max.apply(Math, scope['chartDatas' + dindex].data1.yData1[1]));
          minAndMax1.yData1MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].data1.yData1[2]), Math.max.apply(Math, scope['chartDatas' + dindex].data1.yData1[2]));
          minAndMax1.yData2MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].data1.yData2[0]), Math.max.apply(Math, scope['chartDatas' + dindex].data1.yData2[0]));
          minAndMax1.yData2MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].data1.yData2[1]), Math.max.apply(Math, scope['chartDatas' + dindex].data1.yData2[1]));
          minAndMax1.yData2MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].data1.yData2[2]), Math.max.apply(Math, scope['chartDatas' + dindex].data1.yData2[2]));
          minAndMax2.yData1MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].data2.yData1[0]), Math.max.apply(Math, scope['chartDatas' + dindex].data2.yData1[0]));
          minAndMax2.yData1MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].data2.yData1[1]), Math.max.apply(Math, scope['chartDatas' + dindex].data2.yData1[1]));
          minAndMax2.yData1MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].data2.yData1[2]), Math.max.apply(Math, scope['chartDatas' + dindex].data2.yData1[2]));
          minAndMax2.yData2MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].data2.yData2[0]), Math.max.apply(Math, scope['chartDatas' + dindex].data2.yData2[0]));
          minAndMax2.yData2MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].data2.yData2[1]), Math.max.apply(Math, scope['chartDatas' + dindex].data2.yData2[1]));
          minAndMax2.yData2MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].data2.yData2[2]), Math.max.apply(Math, scope['chartDatas' + dindex].data2.yData2[2]));
          minAndMax3.yData1MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].data3.yData1[0]), Math.max.apply(Math, scope['chartDatas' + dindex].data3.yData1[0]));
          minAndMax3.yData1MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].data3.yData1[1]), Math.max.apply(Math, scope['chartDatas' + dindex].data3.yData1[1]));
          minAndMax3.yData1MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].data3.yData1[2]), Math.max.apply(Math, scope['chartDatas' + dindex].data3.yData1[2]));
          minAndMax3.yData2MinAndMax[0].push(Math.min.apply(Math, scope['chartDatas' + dindex].data3.yData2[0]), Math.max.apply(Math, scope['chartDatas' + dindex].data3.yData2[0]));
          minAndMax3.yData2MinAndMax[1].push(Math.min.apply(Math, scope['chartDatas' + dindex].data3.yData2[1]), Math.max.apply(Math, scope['chartDatas' + dindex].data3.yData2[1]));
          minAndMax3.yData2MinAndMax[2].push(Math.min.apply(Math, scope['chartDatas' + dindex].data3.yData2[2]), Math.max.apply(Math, scope['chartDatas' + dindex].data3.yData2[2]));
          if (scope.compareFlag === 1) {
            scope.maxAndMins.minAndMax1 = minAndMax1;
            scope.maxAndMins.minAndMax2 = minAndMax2;
            scope.maxAndMins.minAndMax3 = minAndMax3;
            scope.currentMinAndMax[0] = minAndMax1.yData1MinAndMax[0];
            scope.currentMinAndMax[1] = minAndMax1.yData2MinAndMax[0];
          } else if (scope.compareFlag === 2) {
            scope.maxAndMins2.minAndMax1 = minAndMax1;
            scope.maxAndMins2.minAndMax2 = minAndMax2;
            scope.maxAndMins2.minAndMax3 = minAndMax3;
            scope.compareMinAndMax[0] = minAndMax1.yData1MinAndMax[0];
            scope.compareMinAndMax[1] = minAndMax1.yData2MinAndMax[0];
          }
          return scope.$applyAsync();
        };
      })(this);
      reSetOringinChartOpts = (function(_this) {
        return function(opts) {
          var index, item, series1, _i, _len, _ref2;
          series1 = [];
          _ref2 = opts.yData;
          for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
            item = _ref2[index];
            series1.push({
              data: item
            });
          }
          return scope.mychart.setOption({
            series: series1
          });
        };
      })(this);
      reSetChartOpts = (function(_this) {
        return function(opts) {
          var legend1, legend2, series1, series2;
          series1 = [];
          series2 = [];
          legend1 = opts.currentLegends.legend1;
          legend2 = opts.currentLegends.legend2;
          series1.push({
            name: legend1,
            data: opts.yData1
          });
          series2.push({
            name: legend2,
            data: opts.yData2
          });
          scope.echart1.setOption({
            legend: {
              data: legend1
            },
            series: series1
          });
          return scope.echart2.setOption({
            legend: {
              data: legend2
            },
            series: series2
          });
        };
      })(this);
      appendStreamData = (function(_this) {
        return function(index) {
          var colors, gtx, legend1, legend2, legend3, legend4, series1, series2, visualMap1, visualMap2;
          series1 = [];
          series2 = [];
          colors = ['#1A45A2', '#00E7EE', '#90D78A', '#1CAA9E', '#F9722C', '#FF085C'];
          legend1 = '当前' + scope.chartOpts1.currentLegends.legend1;
          legend2 = '对比' + scope.chartOpts2.currentLegends.legend1;
          legend3 = '当前' + scope.chartOpts1.currentLegends.legend2;
          legend4 = '对比' + scope.chartOpts2.currentLegends.legend2;
          visualMap1 = [];
          visualMap2 = [];
          gtx = [[-20000000, 20000000], [0, 50]];
          visualMap1.push({
            seriesIndex: 0,
            pieces: [
              {
                gt: gtx[0][0],
                lte: gtx[0][1],
                color: colors[0]
              }
            ]
          }, {
            seriesIndex: 1,
            show: false,
            pieces: [
              {
                gt: gtx[0][0],
                lte: gtx[0][1],
                color: colors[1]
              }
            ],
            outOfRange: {
              color: 'red'
            }
          });
          visualMap2.push({
            seriesIndex: 0,
            pieces: [
              {
                gt: gtx[1][0],
                lte: gtx[1][1],
                color: colors[2]
              }
            ],
            outOfRange: {
              color: 'red'
            }
          }, {
            seriesIndex: 1,
            show: false,
            pieces: [
              {
                gt: gtx[1][0],
                lte: gtx[1][1],
                color: colors[3]
              }
            ],
            outOfRange: {
              color: 'red'
            }
          });
          series1.push({
            name: legend1,
            type: 'line',
            data: scope.chartOpts1.yData1
          }, {
            name: legend2,
            type: 'line',
            data: scope.chartOpts2.yData1
          });
          series2.push({
            name: legend3,
            type: 'line',
            data: scope.chartOpts1.yData2
          }, {
            name: legend4,
            type: 'line',
            data: scope.chartOpts2.yData2
          });
          scope.$root.loading = false;
          scope.echart1.setOption({
            visualMap: visualMap1,
            legend: {
              data: [legend1, legend2]
            },
            series: series1
          });
          return scope.echart2.setOption({
            visualMap: visualMap2,
            legend: {
              data: [legend3, legend4]
            },
            series: series2
          });
        };
      })(this);
      scope.chartShowAll = (function(_this) {
        return function() {
          var abcIndex, index, legendIndex;
          clearInterval(scope.interval1);
          scope.playFlag = false;
          if (scope.streamType === 1 && scope.compareFlag === 1) {
            if (scope.mychart && scope.chartOpts1 && scope.chartDatas1.xData) {
              if (scope.chartOpts1.legends.length === 1) {
                scope.chartOpts1.yData[0] = scope.chartDatas1.yData[0];
              } else {
                scope.chartOpts1.yData[0] = scope.chartDatas1.yData[0];
                scope.chartOpts1.yData[1] = scope.chartDatas1.yData[1];
                scope.chartOpts1.yData[2] = scope.chartDatas1.yData[2];
              }
              return reSetOringinChartOpts(scope.chartOpts1);
            }
          } else if (scope.streamType === 1 && scope.compareFlag === 2) {
            if (scope.mychart && scope.chartOpts1 && scope.chartDatas1.xData) {
              if (scope.chartOpts1.legends.length === 1) {
                scope.chartOpts1.yData[0] = scope.chartDatas1.yData[0];
                scope.chartOpts2.yData[0] = scope.chartDatas2.yData[0];
              } else {
                scope.chartOpts1.yData[0] = scope.chartDatas1.yData[0];
                scope.chartOpts1.yData[1] = scope.chartDatas1.yData[1];
                scope.chartOpts1.yData[2] = scope.chartDatas1.yData[2];
                scope.chartOpts2.yData[0] = scope.chartDatas2.yData[0];
                scope.chartOpts2.yData[1] = scope.chartDatas2.yData[1];
                scope.chartOpts2.yData[2] = scope.chartDatas2.yData[2];
              }
              return appendOriginStreamData();
            }
          } else if (scope.streamType === 2 && scope.compareFlag === 1) {
            if (scope.echart1 && scope.chartOpts1 && scope.chartDatas1.xData) {
              if (scope.dataNumFlag === 1) {
                legendIndex = Number(scope.chartOpts1.currentLegends.index);
                scope.chartOpts1.yData1 = scope.chartDatas1.yData1[legendIndex];
                scope.chartOpts1.yData2 = scope.chartDatas1.yData2[legendIndex];
              } else {
                abcIndex = Number(scope.chartOpts1.currentAbcSeries.index + 1);
                legendIndex = Number(scope.chartOpts1.currentLegends.index);
                scope.chartOpts1.yData1 = scope.chartDatas1['data' + abcIndex].yData1[legendIndex];
                scope.chartOpts1.yData2 = scope.chartDatas1['data' + abcIndex].yData2[legendIndex];
              }
              return reSetChartOpts(scope.chartOpts1);
            }
          } else if (scope.streamType === 2 && scope.compareFlag === 2) {
            if (scope.echart1 && scope.chartOpts1 && scope.chartDatas1.xData) {
              if (scope.dataNumFlag === 1) {
                index = scope.chartOpts1.currentLegends.index;
                scope.chartOpts1.yData1 = scope.chartDatas1.yData1[index];
                scope.chartOpts1.yData2 = scope.chartDatas1.yData2[index];
                scope.chartOpts2.yData1 = scope.chartDatas2.yData1[index];
                scope.chartOpts2.yData2 = scope.chartDatas2.yData2[index];
              } else {
                abcIndex = Number(scope.chartOpts1.currentAbcSeries.index + 1);
                legendIndex = Number(scope.chartOpts1.currentLegends.index);
                scope.chartOpts1.yData1 = scope.chartDatas1['data' + abcIndex].yData1[legendIndex];
                scope.chartOpts1.yData2 = scope.chartDatas1['data' + abcIndex].yData2[legendIndex];
                scope.chartOpts2.yData1 = scope.chartDatas2['data' + abcIndex].yData1[legendIndex];
                scope.chartOpts2.yData2 = scope.chartDatas2['data' + abcIndex].yData2[legendIndex];
              }
              return appendStreamData();
            }
          }
        };
      })(this);
      scope.chartPlayPause = (function(_this) {
        return function() {
          var abcIndex, index, legendIndex;
          if (!scope.playFlag) {
            if (scope.streamType === 1) {
              if (scope.compareFlag === 1) {
                if (scope.mychart && scope.chartOpts1 && scope.chartDatas1.xData) {
                  if (scope.chartOpts1.yData[0].length === scope.chartDatas1.xData.length) {
                    if (scope.chartOpts1.legends.length === 3) {
                      scope.chartOpts1.yData = [[], [], []];
                    } else {
                      scope.chartOpts1.yData = [[]];
                    }
                  }
                  scope.playFlag = true;
                  return scope.interval1 = setInterval(function() {
                    var i;
                    if (scope.chartOpts1.yData[0].length < scope.chartDatas1.xData.length) {
                      i = 0;
                      while (i < 4) {
                        if (scope.chartOpts1.legends.length === 3) {
                          scope.chartOpts1.yData[0].push(scope.chartDatas1.yData[0][scope.chartOpts1.yData[0].length]);
                          scope.chartOpts1.yData[1].push(scope.chartDatas1.yData[1][scope.chartOpts1.yData[1].length]);
                          scope.chartOpts1.yData[2].push(scope.chartDatas1.yData[2][scope.chartOpts1.yData[2].length]);
                        } else {
                          scope.chartOpts1.yData[0].push(scope.chartDatas1.yData[0][scope.chartOpts1.yData[0].length]);
                        }
                        i++;
                      }
                    } else {
                      scope.chartOpts1.yData = [[]];
                    }
                    return reSetOringinChartOpts(scope.chartOpts1);
                  }, 1000);
                }
              } else if (scope.compareFlag === 2) {
                if (scope.mychart && scope.chartOpts1 && scope.chartDatas1.xData) {
                  if (scope.chartOpts1.yData[0].length === scope.chartDatas1.xData.length) {
                    if (scope.chartOpts1.legends.length === 3) {
                      scope.chartOpts1.yData = [[], [], []];
                      scope.chartOpts2.yData = [[], [], []];
                    } else {
                      scope.chartOpts1.yData = [[]];
                      scope.chartOpts2.yData = [[]];
                    }
                  }
                  scope.playFlag = true;
                  return scope.interval1 = setInterval(function() {
                    var i;
                    if (scope.chartOpts1.yData[0].length < scope.chartDatas1.xData.length) {
                      i = 0;
                      while (i < 4) {
                        if (scope.chartOpts1.legends.length === 3) {
                          scope.chartOpts1.yData[0].push(scope.chartDatas1.yData[0][scope.chartOpts1.yData[0].length]);
                          scope.chartOpts1.yData[1].push(scope.chartDatas1.yData[1][scope.chartOpts1.yData[1].length]);
                          scope.chartOpts1.yData[2].push(scope.chartDatas1.yData[2][scope.chartOpts1.yData[2].length]);
                          scope.chartOpts2.yData[0].push(scope.chartDatas2.yData[0][scope.chartOpts2.yData[0].length]);
                          scope.chartOpts2.yData[1].push(scope.chartDatas2.yData[1][scope.chartOpts2.yData[1].length]);
                          scope.chartOpts2.yData[2].push(scope.chartDatas2.yData[2][scope.chartOpts2.yData[2].length]);
                        } else {
                          scope.chartOpts1.yData[0].push(scope.chartDatas1.yData[0][scope.chartOpts1.yData[0].length]);
                          scope.chartOpts2.yData[0].push(scope.chartDatas2.yData[0][scope.chartOpts2.yData[0].length]);
                        }
                        i++;
                      }
                    } else {
                      scope.chartOpts1.yData = [[]];
                      scope.chartOpts2.yData = [[]];
                    }
                    return appendOriginStreamData();
                  }, 1000);
                }
              }
            } else if (scope.streamType === 2) {
              if (scope.compareFlag === 1) {
                if (scope.echart1 && scope.chartOpts1 && scope.chartDatas1.xData) {
                  if (scope.chartOpts1.yData1.length === scope.chartDatas1.xData.length) {
                    scope.chartOpts1.yData1 = [];
                    scope.chartOpts1.yData2 = [];
                  }
                  scope.playFlag = true;
                  if (scope.dataNumFlag === 1) {
                    legendIndex = Number(scope.chartOpts1.currentLegends.index);
                    return scope.interval1 = setInterval(function() {
                      var i;
                      if (scope.chartOpts1.yData1.length < scope.chartDatas1.xData.length) {
                        i = 0;
                        while (i < 2) {
                          scope.chartOpts1.yData1.push(scope.chartDatas1.yData1[legendIndex][scope.chartOpts1.yData1.length]);
                          scope.chartOpts1.yData2.push(scope.chartDatas1.yData2[legendIndex][scope.chartOpts1.yData2.length]);
                          i++;
                        }
                      } else {
                        scope.chartOpts1.yData1 = [];
                        scope.chartOpts1.yData2 = [];
                      }
                      return reSetChartOpts(scope.chartOpts1);
                    }, 1000);
                  } else if (scope.dataNumFlag === 3) {
                    abcIndex = Number(scope.chartOpts1.currentAbcSeries.index + 1);
                    legendIndex = Number(scope.chartOpts1.currentLegends.index);
                    return scope.interval1 = setInterval(function() {
                      var i;
                      if (scope.chartOpts1.yData1.length < scope.chartDatas1.xData.length) {
                        i = 0;
                        while (i < 2) {
                          scope.chartOpts1.yData1.push(scope.chartDatas1['data' + abcIndex].yData1[legendIndex][scope.chartOpts1.yData1.length]);
                          scope.chartOpts1.yData2.push(scope.chartDatas1['data' + abcIndex].yData2[legendIndex][scope.chartOpts1.yData2.length]);
                          i++;
                        }
                      } else {
                        scope.chartOpts1.yData1 = [];
                        scope.chartOpts1.yData2 = [];
                      }
                      return reSetChartOpts(scope.chartOpts1);
                    }, 1000);
                  }
                }
              } else if (scope.compareFlag === 2) {
                if (scope.echart1 && scope.chartOpts1 && scope.chartDatas1.xData) {
                  if (scope.chartOpts1.yData1.length === scope.chartDatas1.xData.length) {
                    scope.chartOpts1.yData1 = [];
                    scope.chartOpts1.yData2 = [];
                    scope.chartOpts2.yData1 = [];
                    scope.chartOpts2.yData2 = [];
                  }
                  scope.playFlag = true;
                  if (scope.dataNumFlag === 1) {
                    index = scope.chartOpts1.currentLegends.index;
                    return scope.interval1 = setInterval(function() {
                      var i;
                      if (scope.chartOpts1.yData1.length < scope.chartDatas1.xData.length) {
                        i = 0;
                        while (i < 2) {
                          scope.chartOpts1.yData1.push(scope.chartDatas1.yData1[index][scope.chartOpts1.yData1.length]);
                          scope.chartOpts1.yData2.push(scope.chartDatas1.yData2[index][scope.chartOpts1.yData2.length]);
                          scope.chartOpts2.yData1.push(scope.chartDatas2.yData1[index][scope.chartOpts2.yData1.length]);
                          scope.chartOpts2.yData2.push(scope.chartDatas2.yData2[index][scope.chartOpts2.yData2.length]);
                          i++;
                        }
                      } else {
                        scope.chartOpts1.yData1 = [];
                        scope.chartOpts1.yData2 = [];
                        scope.chartOpts2.yData1 = [];
                        scope.chartOpts2.yData2 = [];
                      }
                      return appendStreamData();
                    }, 1000);
                  } else if (scope.dataNumFlag === 3) {
                    abcIndex = Number(scope.chartOpts1.currentAbcSeries.index + 1);
                    legendIndex = Number(scope.chartOpts1.currentLegends.index);
                    return scope.interval1 = setInterval(function() {
                      var i;
                      if (scope.chartOpts1.yData1.length < scope.chartDatas1.xData.length) {
                        i = 0;
                        while (i < 2) {
                          scope.chartOpts1.yData1.push(scope.chartDatas1['data' + abcIndex].yData1[legendIndex][scope.chartOpts1.yData1.length]);
                          scope.chartOpts1.yData2.push(scope.chartDatas1['data' + abcIndex].yData2[legendIndex][scope.chartOpts1.yData2.length]);
                          scope.chartOpts2.yData1.push(scope.chartDatas2['data' + abcIndex].yData1[legendIndex][scope.chartOpts2.yData1.length]);
                          scope.chartOpts2.yData2.push(scope.chartDatas2['data' + abcIndex].yData2[legendIndex][scope.chartOpts2.yData2.length]);
                          i++;
                        }
                      } else {
                        scope.chartOpts1.yData1 = [];
                        scope.chartOpts1.yData2 = [];
                        scope.chartOpts2.yData1 = [];
                        scope.chartOpts2.yData2 = [];
                      }
                      return appendStreamData();
                    }, 1000);
                  }
                }
              }
            }
          } else {
            clearInterval(scope.interval1);
            return scope.playFlag = false;
          }
        };
      })(this);
      appendOriginStreamData = (function(_this) {
        return function(zindex) {
          var colors, index, item, legend, series1, _i, _j, _legendData1, _legendData2, _len, _len1, _ref2, _ref3;
          series1 = [];
          _legendData1 = _.map(scope.chartOpts1.legends, function(d, i) {
            return {
              name: '当前' + d,
              icon: "image://" + _this.getComponentPath('image/color' + (i + 1) + '.svg')
            };
          });
          _legendData2 = _.map(scope.chartOpts1.legends, function(d, i) {
            return {
              name: '对比' + d,
              icon: "image://" + _this.getComponentPath('image/color' + ((i + _legendData1.length) % 3 + 1) + '.svg')
            };
          });
          legend = _legendData1.concat(_legendData2);
          colors = [['#1A45A2', '#00E7EE'], ['#90D78A', '#1CAA9E'], ['#F9722C', '#FF085C']];
          _ref2 = scope.chartOpts1.yData;
          for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
            item = _ref2[index];
            series1.push({
              type: 'line',
              name: _legendData1[index].name,
              data: item,
              lineStyle: {
                width: 2,
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: colors[index][0]
                    }, {
                      offset: 1,
                      color: colors[index][1]
                    }
                  ]
                }
              }
            });
          }
          _ref3 = scope.chartOpts2.yData;
          for (index = _j = 0, _len1 = _ref3.length; _j < _len1; index = ++_j) {
            item = _ref3[index];
            series1.push({
              type: 'line',
              name: _legendData2[index].name,
              data: item,
              lineStyle: {
                width: 2,
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: colors[(index + series1.length) % 3][0]
                    }, {
                      offset: 1,
                      color: colors[(index + series1.length) % 3][1]
                    }
                  ]
                }
              }
            });
          }
          scope.$root.loading = false;
          return scope.mychart.setOption({
            legend: {
              data: legend
            },
            series: series1
          });
        };
      })(this);
      scope.InitChartOpt = (function(_this) {
        return function() {
          var myChart1, myChart2, option1, option2, _ref2, _ref3;
          myChart1 = element.find("#ss-chart1");
          myChart2 = element.find("#ss-chart2");
          if ((_ref2 = scope.echart1) != null) {
            _ref2.dispose();
          }
          if ((_ref3 = scope.echart2) != null) {
            _ref3.dispose();
          }
          scope.echart1 = echarts.init(myChart1[0]);
          scope.echart2 = echarts.init(myChart2[0]);
          option1 = _this.createOption(scope.chartOpts1, 0);
          option2 = _this.createOption(scope.chartOpts1, 1);
          scope.$root.loading = false;
          scope.echart1.setOption(option1);
          return scope.echart2.setOption(option2);
        };
      })(this);
      originStreamData2 = (function(_this) {
        return function(url, zindex) {
          var str;
          str = url.split(',');
          scope.compareMinAndMax = [0, 0];
          if (str.length === 1) {
            scope.chartDatas2.yData = [[]];
            scope.chartDatas2.xData = [];
            return $.get(str[0], null, function(data) {
              var i, index, j, strs, _i, _len;
              strs = data.split("\n");
              strs.pop();
              for (j = _i = 0, _len = strs.length; _i < _len; j = ++_i) {
                i = strs[j];
                index = j + 1;
                scope.chartDatas2.xData.push(index);
                scope.chartDatas2.yData[0].push(Number(i));
              }
              scope.chartOpts2.yData = scope.chartDatas2.yData;
              scope.chartOpts2.xData = scope.chartDatas2.xData;
              scope.calcCompareMinAndMax(scope.chartDatas2.yData);
              return appendOriginStreamData();
            });
          } else if (str.length === 3) {
            scope.chartDatas2.yData = [[], [], []];
            scope.chartDatas2.xData = [];
            return $.get(str[0], null, function(data1) {
              var i, index, j, strs, _i, _len;
              strs = data1.split("\n");
              strs.pop();
              for (j = _i = 0, _len = strs.length; _i < _len; j = ++_i) {
                i = strs[j];
                index = j + 1;
                scope.chartDatas2.xData.push(index);
                scope.chartDatas2.yData[0].push(Number(i));
              }
              return $.get(str[1], null, function(data2) {
                var _j, _len1;
                strs = data2.split("\n");
                strs.pop();
                for (_j = 0, _len1 = strs.length; _j < _len1; _j++) {
                  j = strs[_j];
                  scope.chartDatas2.yData[1].push(Number(j));
                }
                return $.get(str[2], null, function(data3) {
                  var k, _k, _len2;
                  strs = data3.split("\n");
                  strs.pop();
                  for (_k = 0, _len2 = strs.length; _k < _len2; _k++) {
                    k = strs[_k];
                    scope.chartDatas2.yData[2].push(Number(k));
                  }
                  scope.chartOpts2.yData = scope.chartDatas2.yData;
                  scope.chartOpts2.xData = scope.chartDatas2.xData;
                  scope.calcCompareMinAndMax(scope.chartDatas2.yData);
                  return appendOriginStreamData();
                });
              });
            });
          }
        };
      })(this);
      getStreamDataOrigin = (function(_this) {
        return function(zindex) {
          var filter, strId, _ref2;
          console.log(scope);
          filter = {
            user: scope.project.model.user,
            project: scope.project.model.project,
            station: scope.selectedEquips[0].station,
            equipment: scope.selectedEquips[0].id,
            signal: scope.selectSignals[0].model.signal
          };
          strId = scope.selectedEquips[0].station + "-" + scope.selectedEquips[0].id + "-" + scope.selectSignals[0].model.signal;
          scope.chartOpts1.title = scope.selectSignals[0].model.name + '原始数据图';
          if ((_ref2 = scope.equipSubscription[strId]) != null) {
            _ref2.dispose();
          }
          return scope.equipSubscription[strId] = _this.commonService.signalLiveSession.subscribeValues(filter, function(err, signal) {
            var chartelement, item, str, _i, _len, _ref3;
            scope.chartDatas1.xData = [];
            scope.urls = [];
            if (signal.message && signal.message.value) {
              scope.dataFlag = true;
              scope.$root.loading = true;
              chartelement = element.find('#ss-origin-chart');
              if ((_ref3 = scope.mychart) != null) {
                _ref3.dispose();
              }
              scope.mychart = null;
              scope.mychart = echarts.init(chartelement[0]);
              scope.collectTime = moment(signal.message.timestamp).format("YYYY-MM-DD HH:mm:ss");
              str = signal.message.value.split(',');
              for (_i = 0, _len = str.length; _i < _len; _i++) {
                item = str[_i];
                scope.urls.push(item);
              }
              if (scope.urls.length === 1) {
                scope.chartDatas1.yData = [[]];
                return $.get(scope.urls[0], null, function(data) {
                  var i, index, j, strs, _j, _len1;
                  strs = data.split("\n");
                  strs.pop();
                  for (j = _j = 0, _len1 = strs.length; _j < _len1; j = ++_j) {
                    i = strs[j];
                    index = j + 1;
                    scope.chartDatas1.xData.push(index);
                    scope.chartDatas1.yData[0].push(Number(i));
                  }
                  scope.chartOpts1.yData = scope.chartDatas1.yData;
                  scope.chartOpts1.xData = scope.chartDatas1.xData;
                  scope.calcMinAndMax(scope.chartDatas1.yData);
                  scope.$root.loading = false;
                  return createOriginOption(scope.chartOpts1);
                });
              } else if (scope.urls.length === 3) {
                scope.chartDatas1.yData = [[], [], []];
                return $.get(scope.urls[0], null, function(data1) {
                  var i, index, j, strs, _j, _len1;
                  strs = data1.split("\n");
                  strs.pop();
                  for (j = _j = 0, _len1 = strs.length; _j < _len1; j = ++_j) {
                    i = strs[j];
                    index = j + 1;
                    scope.chartDatas1.xData.push(index);
                    scope.chartDatas1.yData[0].push(Number(i));
                  }
                  return $.get(scope.urls[1], null, function(data2) {
                    var _k, _len2;
                    strs = data2.split("\n");
                    strs.pop();
                    for (_k = 0, _len2 = strs.length; _k < _len2; _k++) {
                      j = strs[_k];
                      scope.chartDatas1.yData[1].push(Number(j));
                    }
                    return $.get(scope.urls[2], null, function(data3) {
                      var k, _l, _len3;
                      strs = data3.split("\n");
                      strs.pop();
                      for (_l = 0, _len3 = strs.length; _l < _len3; _l++) {
                        k = strs[_l];
                        scope.chartDatas1.yData[2].push(Number(k));
                      }
                      scope.chartOpts1.yData = scope.chartDatas1.yData;
                      scope.chartOpts1.xData = scope.chartDatas1.xData;
                      scope.calcMinAndMax(scope.chartDatas1.yData);
                      scope.$root.loading = false;
                      return createOriginOption(scope.chartOpts1);
                    });
                  });
                });
              }
            }
          });
        };
      })(this);
      scope.checkIfNumber = (function(_this) {
        return function(val) {
          if (!isNaN(Number(val))) {
            return Number(val);
          } else {
            return 0;
          }
        };
      })(this);
      scope.calcMinAndMax = (function(_this) {
        return function(data) {
          var i, index, item, j, k, newData, yDataMinAndMax, _i, _j, _k, _len, _len1, _len2;
          yDataMinAndMax = [];
          newData = [];
          for (j = _i = 0, _len = data.length; _i < _len; j = ++_i) {
            i = data[j];
            newData.push([]);
            for (_j = 0, _len1 = i.length; _j < _len1; _j++) {
              k = i[_j];
              newData[j].push(scope.checkIfNumber(k));
            }
          }
          if (data.length === 3) {
            for (index = _k = 0, _len2 = newData.length; _k < _len2; index = ++_k) {
              item = newData[index];
              yDataMinAndMax.push(Math.min.apply(Math, item), Math.max.apply(Math, item));
            }
            scope.currentMinAndMax = [Math.min.apply(Math, yDataMinAndMax), Math.max.apply(Math, yDataMinAndMax)];
          } else {
            yDataMinAndMax.push(Math.min.apply(Math, newData[0]), Math.max.apply(Math, newData[0]));
            scope.currentMinAndMax = yDataMinAndMax;
          }
          return scope.$applyAsync();
        };
      })(this);
      scope.calcCompareMinAndMax = (function(_this) {
        return function(data) {
          var i, index, item, j, k, newData, yDataMinAndMax, _i, _j, _k, _len, _len1, _len2;
          yDataMinAndMax = [];
          newData = [];
          for (j = _i = 0, _len = data.length; _i < _len; j = ++_i) {
            i = data[j];
            newData.push([]);
            for (_j = 0, _len1 = i.length; _j < _len1; _j++) {
              k = i[_j];
              newData[j].push(scope.checkIfNumber(k));
            }
          }
          if (data.length === 3) {
            for (index = _k = 0, _len2 = newData.length; _k < _len2; index = ++_k) {
              item = newData[index];
              yDataMinAndMax.push(Math.min.apply(Math, item), Math.max.apply(Math, item));
            }
            scope.compareMinAndMax = [Math.min.apply(Math, yDataMinAndMax), Math.max.apply(Math, yDataMinAndMax)];
          } else {
            yDataMinAndMax.push(Math.min.apply(Math, newData[0]), Math.max.apply(Math, newData[0]));
            scope.compareMinAndMax = yDataMinAndMax;
          }
          return scope.$applyAsync();
        };
      })(this);
      return createOriginOption = (function(_this) {
        return function(opts) {
          var colors, index, item, option, series, _i, _legendData, _len, _ref2;
          colors = [['#1A45A2', '#00E7EE'], ['#90D78A', '#1CAA9E'], ['#F9722C', '#FF085C']];
          series = [];
          _ref2 = opts.yData;
          for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
            item = _ref2[index];
            series.push({
              name: opts.legends[index],
              type: 'line',
              symbol: "none",
              smooth: true,
              data: item,
              lineStyle: {
                width: 2,
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: colors[index][0]
                    }, {
                      offset: 1,
                      color: colors[index][1]
                    }
                  ]
                }
              }
            });
          }
          _legendData = _.map(opts.legends, function(d, i) {
            return {
              name: d,
              icon: "image://" + _this.getComponentPath('image/color' + (i + 1) + '.svg')
            };
          });
          option = {
            title: {
              text: opts.title,
              textStyle: {
                color: '#fff'
              },
              left: 'center',
              top: 0
            },
            tooltip: {
              show: true,
              trigger: "axis",
              axisPointer: {
                type: 'cross'
              }
            },
            legend: {
              show: true,
              bottom: '4%',
              orient: "horizontal",
              textStyle: {
                fontSize: 14,
                color: "#FFFFFF"
              },
              data: _legendData
            },
            grid: {
              right: 20
            },
            toolbox: {
              show: true,
              right: 20,
              feature: {
                dataZoom: {
                  show: false
                },
                dataView: {
                  show: false
                },
                magicType: {
                  show: false
                },
                restore: {
                  show: false
                },
                saveAsImage: {
                  show: false
                }
              }
            },
            dataZoom: [
              {
                type: 'inside',
                realtime: true,
                start: opts.start,
                end: opts.end
              }, {
                show: true,
                realtime: true,
                type: 'slider',
                height: 20,
                borderColor: 'rgba(2,62,116,1)',
                dataBackground: {
                  lineStyle: {
                    width: 3,
                    color: {
                      type: 'linear',
                      x: 0,
                      y: 0,
                      x2: 0,
                      y2: 1,
                      colorStops: [
                        {
                          offset: 0,
                          color: '#1A45A2'
                        }, {
                          offset: 1,
                          color: '#00E7EE'
                        }
                      ]
                    }
                  },
                  areaStyle: {
                    color: {
                      type: 'linear',
                      x: 0,
                      y: 0,
                      x2: 0,
                      y2: 1,
                      colorStops: [
                        {
                          offset: 0,
                          color: '#1A45A2'
                        }, {
                          offset: 1,
                          color: '#00E7EE'
                        }
                      ]
                    }
                  }
                },
                handleStyle: {
                  color: 'rgba(0,167,255,1)'
                },
                textStyle: {
                  fontSize: 14,
                  color: "#FFFFFF"
                },
                fillerColor: "rgba(2,62,116,0.8)",
                bottom: 0
              }
            ],
            xAxis: {
              show: false,
              nameTextStyle: {
                color: 'rgba(156,165,193,1)'
              },
              data: opts.xData,
              type: 'category',
              boundaryGap: false,
              nameLocation: "middle",
              axisLine: {
                onZero: false,
                lineStyle: {
                  color: "#204BAD"
                }
              },
              axisLabel: {
                show: false,
                textStyle: {
                  color: 'rgba(156,165,193,1)'
                }
              }
            },
            yAxis: {
              type: 'value',
              axisLine: {
                lineStyle: {
                  color: "#204BAD"
                }
              },
              axisLabel: {
                textStyle: {
                  color: 'rgba(156,165,193,1)'
                }
              },
              splitLine: {
                lineStyle: {
                  color: ["#204BAD"]
                }
              }
            },
            series: series
          };
          scope.$root.loading = false;
          return scope.mychart.setOption(option);
        };
      })(this);
    };

    StreamCompareDirective.prototype.createOption = function(opts, index) {
      var color, i, option, series, title, visualMap;
      i = Number(index + 1);
      color = ['#00E7EE', '#4169E1', '#90D78A', '#1CAA9E'];
      title = ['时间(ms)', '频率(Hz)'];
      series = {
        name: opts.currentLegends['legend' + i],
        type: 'line',
        symbol: "none",
        lineStyle: {
          width: 1
        },
        smooth: true,
        data: opts['yData' + i]
      };
      visualMap = [
        {
          top: 10,
          left: 10,
          seriesIndex: 0,
          textStyle: {
            color: '#fff'
          },
          pieces: [
            {
              gt: opts.normalDatas[index][0],
              lte: opts.normalDatas[index][1],
              color: color[index]
            }
          ],
          outOfRange: {
            color: 'red'
          }
        }
      ];
      option = {
        title: {
          text: opts['title' + i],
          textStyle: {
            color: '#fff'
          },
          left: 'center',
          top: 0
        },
        tooltip: {
          show: true,
          trigger: "axis",
          axisPointer: {
            type: 'cross'
          }
        },
        legend: {
          show: true,
          orient: "horizontal",
          right: 0,
          textStyle: {
            fontSize: 14,
            color: "#FFFFFF"
          },
          data: opts.currentLegends['legend' + i]
        },
        grid: {
          right: 5
        },
        toolbox: {
          show: true,
          right: 0,
          feature: {
            dataZoom: {
              show: false
            },
            dataView: {
              show: false
            },
            magicType: {
              show: false,
              type: ['line', 'bar']
            },
            restore: {
              show: false
            },
            saveAsImage: {
              show: false
            }
          }
        },
        visualMap: visualMap,
        dataZoom: [
          {
            type: 'inside',
            realtime: true,
            start: opts.start,
            end: opts.end
          }, {
            show: true,
            realtime: true,
            type: 'slider',
            height: 20,
            borderColor: 'rgba(2,62,116,1)',
            dataBackground: {
              lineStyle: {
                width: 3,
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: '#1A45A2'
                    }, {
                      offset: 1,
                      color: '#00E7EE'
                    }
                  ]
                }
              },
              areaStyle: {
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: '#1A45A2'
                    }, {
                      offset: 1,
                      color: '#00E7EE'
                    }
                  ]
                }
              }
            },
            handleStyle: {
              color: 'rgba(0,167,255,1)'
            },
            textStyle: {
              fontSize: 14,
              color: "#FFFFFF"
            },
            fillerColor: "rgba(2,62,116,0.8)",
            bottom: 0
          }
        ],
        xAxis: {
          name: title[index],
          nameTextStyle: {
            color: 'rgba(156,165,193,1)'
          },
          data: opts.xData,
          type: 'category',
          boundaryGap: false,
          nameLocation: "middle",
          axisLine: {
            onZero: false,
            lineStyle: {
              color: "#204BAD"
            }
          },
          axisLabel: {
            show: false,
            textStyle: {
              color: 'rgba(156,165,193,1)'
            }
          }
        },
        yAxis: {
          name: '振幅(g)',
          nameLocation: 'middle',
          nameTextStyle: {
            color: 'rgba(156,165,193,1)',
            fontSize: 14,
            padding: [0, 0, 130, 0],
            align: 'left',
            verticalAlign: 'middle'
          },
          type: 'value',
          axisLine: {
            lineStyle: {
              color: "#204BAD"
            }
          },
          axisLabel: {
            textStyle: {
              color: 'rgba(156,165,193,1)'
            }
          },
          splitLine: {
            show: false
          }
        },
        series: series
      };
      return option;
    };

    StreamCompareDirective.prototype.resize = function(scope) {
      return this.$timeout((function(_this) {
        return function() {
          var _ref, _ref1, _ref2;
          if ((_ref = scope.echart1) != null) {
            _ref.resize();
          }
          if ((_ref1 = scope.echart2) != null) {
            _ref1.resize();
          }
          return (_ref2 = scope.mychart) != null ? _ref2.resize() : void 0;
        };
      })(this), 0);
    };

    StreamCompareDirective.prototype.dispose = function(scope) {
      var key, value, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      _ref = scope.equipSubscription;
      for (key in _ref) {
        value = _ref[key];
        if (value != null) {
          value.dispose();
        }
      }
      if ((_ref1 = scope.echart1) != null) {
        _ref1.dispose();
      }
      scope.echart1 = null;
      if ((_ref2 = scope.echart2) != null) {
        _ref2.dispose();
      }
      scope.echart2 = null;
      if ((_ref3 = scope.mychart) != null) {
        _ref3.dispose();
      }
      scope.mychart = null;
      if ((_ref4 = scope.timeSubscription) != null) {
        _ref4.dispose();
      }
      if ((_ref5 = scope.selectEquipSubscription) != null) {
        _ref5.dispose();
      }
      return clearInterval(scope.interval1);
    };

    return StreamCompareDirective;

  })(base.BaseDirective);
  return exports = {
    StreamCompareDirective: StreamCompareDirective
  };
});
