// Generated by IcedCoffeeScript 108.0.13

/*
* File: stream-voice-curve-directive
* User: David
* Date: 2020/03/05
* Desc:
 */
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['jquery', '../base-directive', 'text!./style.css', 'text!./view.html', 'underscore', "moment", "echarts"], function($, base, css, view, _, moment, echarts) {
  var StreamVoiceCurveDirective, exports;
  StreamVoiceCurveDirective = (function(_super) {
    __extends(StreamVoiceCurveDirective, _super);

    function StreamVoiceCurveDirective($timeout, $window, $compile, $routeParams, commonService) {
      this.createOption = __bind(this.createOption, this);
      this.show = __bind(this.show, this);
      this.id = "stream-voice-curve";
      StreamVoiceCurveDirective.__super__.constructor.call(this, $timeout, $window, $compile, $routeParams, commonService);
    }

    StreamVoiceCurveDirective.prototype.setScope = function() {};

    StreamVoiceCurveDirective.prototype.setCSS = function() {
      return css;
    };

    StreamVoiceCurveDirective.prototype.setTemplate = function() {
      return view;
    };

    StreamVoiceCurveDirective.prototype.show = function(scope, element, attrs) {
      var _ref, _ref1;
      scope.playFlag = false;
      scope.interval1 = null;
      scope.equipSubscription = {};
      scope.chartOpts = {};
      scope.chartDatas = {};
      scope.chartOpts.legends = [];
      scope.chartOpts.yDatas = [];
      scope.chartOpts.end = 10;
      scope.chartOpts.start = 0;
      scope.streamLegendList = [];
      scope.currentMinAndMax = [[0, 0], [0, 0]];
      scope.maxAndMins = {};
      scope.chartOpts.legends = [];
      scope.dataFlag = false;
      scope.getStreamSignalData = (function(_this) {
        return function() {
          var filter, strId, _ref;
          filter = {
            user: scope.project.model.user,
            project: scope.project.model.project,
            station: scope.equipment.model.station,
            equipment: scope.equipment.model.equipment,
            signal: scope.parameters.currentSignal + '-ttf'
          };
          strId = scope.equipment.key + "-" + filter.signal;
          if ((_ref = scope.equipSubscription[strId]) != null) {
            _ref.dispose();
          }
          return scope.equipSubscription[strId] = _this.commonService.signalLiveSession.subscribeValues(filter, function(err, signal) {
            var xhr;
            if (signal.message && signal.message.value) {
              console.log(signal);
              scope.collectTime = moment(signal.message.timestamp).format("YYYY-MM-DD HH:mm:ss");
              scope.dataFlag = true;
              scope.dataUrl = signal.message.value;
              scope.$root.loading = true;
              xhr = new XMLHttpRequest();
              xhr.open('get', scope.dataUrl, true);
              xhr.responseType = 'arraybuffer';
              xhr.onload = function(e) {
                var data, testStr, wb;
                if (xhr.status === 200) {
                  data = new Uint8Array(xhr.response);
                  wb = XLSX.read(data, {
                    type: 'array'
                  });
                  testStr = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
                  return scope.jsonToStringData(testStr);
                }
              };
              return xhr.send();
            }
          });
        };
      })(this);
      if (scope.parameters.streamFlag) {
        scope.getStreamSignalData();
      } else {
        if ((_ref = scope.echart1) != null) {
          _ref.dispose();
        }
        scope.echart1 = null;
        if ((_ref1 = scope.echart2) != null) {
          _ref1.dispose();
        }
        scope.echart2 = null;
      }
      scope.InitChartOpt = (function(_this) {
        return function() {
          var myChart1, myChart2, option1, option2;
          myChart1 = element.find("#ss-chart1");
          myChart2 = element.find("#ss-chart2");
          scope.echart1 = echarts.init(myChart1[0]);
          scope.echart2 = echarts.init(myChart2[0]);
          option1 = _this.createOption(scope.chartOpts, 0);
          option2 = _this.createOption(scope.chartOpts, 1);
          scope.$root.loading = false;
          scope.echart1.setOption(option1);
          return scope.echart2.setOption(option2);
        };
      })(this);
      scope.originalStream = (function(_this) {
        return function() {
          _this.commonService.publishEventBus('old-new-stream-flag', 'old');
          return scope.$applyAsync();
        };
      })(this);
      scope.downLoadStream = (function(_this) {
        return function() {
          if (scope.dataUrl) {
            return window.open(scope.dataUrl, '_blank');
          } else {
            return _this.display("暂无数据，无法下载！");
          }
        };
      })(this);
      scope.chartShowAll = (function(_this) {
        return function() {
          var index;
          clearInterval(scope.interval1);
          scope.playFlag = false;
          if (scope.echart1 && scope.chartOpts && scope.chartDatas.xData) {
            index = scope.chartOpts.currentLegends.index;
            scope.chartOpts.yData1 = scope.chartDatas.yData1[index];
            scope.chartOpts.yData2 = scope.chartDatas.yData2[index];
            return scope.reSetChartOpts(scope.chartOpts);
          }
        };
      })(this);
      scope.chartPlayPause = (function(_this) {
        return function() {
          var index;
          if (!scope.playFlag) {
            if (scope.echart1 && scope.chartOpts && scope.chartDatas.xData) {
              if (scope.chartOpts.yData1.length === scope.chartDatas.xData.length) {
                scope.chartOpts.yData1 = [];
                scope.chartOpts.yData2 = [];
              }
              scope.playFlag = true;
              index = scope.chartOpts.currentLegends.index;
              return scope.interval1 = setInterval(function() {
                var i;
                if (scope.chartOpts.yData1.length < scope.chartDatas.xData.length) {
                  i = 0;
                  while (i < 2) {
                    scope.chartOpts.yData1.push(scope.chartDatas.yData1[index][scope.chartOpts.yData1.length]);
                    scope.chartOpts.yData2.push(scope.chartDatas.yData2[index][scope.chartOpts.yData2.length]);
                    i++;
                  }
                } else {
                  scope.chartOpts.yData1 = [];
                  scope.chartOpts.yData2 = [];
                }
                return scope.reSetChartOpts(scope.chartOpts);
              }, 1000);
            }
          } else {
            clearInterval(scope.interval1);
            return scope.playFlag = false;
          }
        };
      })(this);
      scope.selectSeriesData = (function(_this) {
        return function(leg, index) {
          clearInterval(scope.interval1);
          scope.chartOpts.currentLegends = scope.streamLegendList[index];
          scope.chartOpts.yData1 = scope.chartDatas.yData1[index];
          scope.chartOpts.yData2 = scope.chartDatas.yData2[index];
          scope.currentMinAndMax[0] = scope.maxAndMins.yData1MinAndMax[index];
          scope.currentMinAndMax[1] = scope.maxAndMins.yData2MinAndMax[index];
          return scope.reSetChartOpts(scope.chartOpts);
        };
      })(this);
      scope.reSetChartOpts = (function(_this) {
        return function(opts) {
          var legend1, legend2, series1, series2;
          series1 = [];
          series2 = [];
          legend1 = opts.currentLegends.legend1;
          legend2 = opts.currentLegends.legend2;
          series1.push({
            name: legend1,
            data: opts.yData1
          });
          series2.push({
            name: legend2,
            data: opts.yData2
          });
          scope.echart1.setOption({
            legend: {
              data: legend1
            },
            series: series1
          });
          return scope.echart2.setOption({
            legend: {
              data: legend2
            },
            series: series2
          });
        };
      })(this);
      scope.jsonToStringData = (function(_this) {
        return function(data) {
          var i, item, j, k, keyData, name, name1, name2, xData, yData1MinAndMax, yData2MinAndMax, _i, _j, _len, _len1, _ref2;
          if (Array.isArray(data)) {
            xData = [];
            scope.chartDatas.yData1 = [[], [], []];
            scope.chartDatas.yData2 = [[], [], []];
            yData1MinAndMax = [[], [], []];
            yData2MinAndMax = [[], [], []];
            scope.chartOpts.normalDatas = [[-20000000, 20000000], [0, 50]];
            scope.chartOpts.subtext = scope.collectTime;
            keyData = data[0];
            for (j in keyData) {
              k = keyData[j];
              scope.chartOpts.legends.push(j);
            }
            scope.chartOpts.legends.pop();
            console.log(scope.chartOpts.legends);
            for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
              item = data[i];
              xData.push(i + 1);
              scope.chartDatas.yData1[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[0]]));
              scope.chartDatas.yData1[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[1]]));
              scope.chartDatas.yData1[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[2]]));
              scope.chartDatas.yData2[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[3]]));
              scope.chartDatas.yData2[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[4]]));
              scope.chartDatas.yData2[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[5]]));
            }
            scope.chartOpts.xData = xData;
            scope.chartOpts.title1 = scope.parameters.currentName + '时域图';
            scope.chartOpts.title2 = scope.parameters.currentName + '频域图';
            scope.chartOpts.yData1 = scope.chartDatas.yData1[0];
            scope.chartOpts.yData2 = scope.chartDatas.yData2[0];
            _ref2 = [0, 1, 2];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              i = _ref2[_j];
              name1 = scope.chartOpts.legends[i];
              name2 = scope.chartOpts.legends[i + 3];
              name = name1 + ',' + name2;
              scope.streamLegendList.push({
                legend1: name1,
                legend2: name2,
                name: name,
                index: i
              });
            }
            scope.chartOpts.currentLegends = scope.streamLegendList[0];
            scope.chartDatas.xData = xData;
            scope.InitChartOpt();
            yData1MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.yData1[0]), Math.max.apply(Math, scope.chartDatas.yData1[0]));
            yData1MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.yData1[1]), Math.max.apply(Math, scope.chartDatas.yData1[1]));
            yData1MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.yData1[2]), Math.max.apply(Math, scope.chartDatas.yData1[2]));
            yData2MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.yData2[0]), Math.max.apply(Math, scope.chartDatas.yData2[0]));
            yData2MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.yData2[1]), Math.max.apply(Math, scope.chartDatas.yData2[1]));
            yData2MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.yData2[2]), Math.max.apply(Math, scope.chartDatas.yData2[2]));
            scope.maxAndMins.yData1MinAndMax = yData1MinAndMax;
            scope.maxAndMins.yData2MinAndMax = yData2MinAndMax;
            scope.currentMinAndMax[0] = yData1MinAndMax[0];
            scope.currentMinAndMax[1] = yData2MinAndMax[0];
            return scope.$applyAsync();
          }
        };
      })(this);
      scope.checkIfNumber = (function(_this) {
        return function(val) {
          if (!isNaN(Number(val))) {
            return Number(val);
          } else {
            return 0;
          }
        };
      })(this);
      scope.hidemodal = function() {
        return $('#stream-predict-modal').modal('close');
      };
      scope.openModal = function() {
        return $('#stream-predict-modal').modal('open');
      };
      scope.signalDataArr = [];
      scope.submitDatas = {
        currentSignal: '',
        predictNum: 0,
        predictText: ''
      };
      scope.equipment.loadSignals(null, (function(_this) {
        return function(err, signals) {
          var sig, signalValue, _i, _len, _results;
          if (signals) {
            _results = [];
            for (_i = 0, _len = signals.length; _i < _len; _i++) {
              sig = signals[_i];
              if (sig.model.type === scope.equipment.model.type) {
                if (sig.model.template === "base-" + scope.equipment.model.type && sig.model.signal !== "device-flag" && sig.model.signal !== "device-health") {
                  signalValue = {};
                  signalValue.name = sig.model.name;
                  signalValue.signalID = sig.model.signal;
                  signalValue.passId = sig.model.expression.variables[0].value;
                  signalValue.check = false;
                  scope.signalDataArr.push(signalValue);
                  _results.push(scope.submitDatas.currentSignal = scope.signalDataArr[0]);
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        };
      })(this));
      scope.selectStreamSig = (function(_this) {
        return function(type, index) {
          return scope.submitDatas.currentSignal = type;
        };
      })(this);
      scope.compare = (function(_this) {
        return function() {
          return window.location.hash = "#/stream-compare/" + scope.project.model.user + "/" + scope.project.model.project;
        };
      })(this);
      scope.submitMessage = (function(_this) {
        return function() {
          var channel1, channel2Data, i, str, su, sus, _i, _len;
          if (Number(scope.submitDatas.predictNum) > 100 || Number(scope.submitDatas.predictNum) < 0) {
            _this.display('预测值为0~100之间!');
          } else {
            channel2Data = {};
            console.log(scope);
            channel1 = scope.submitDatas.currentSignal.passId.split('/')[1];
            channel2Data.mchannel = channel1;
            channel2Data.mvalue = Number(scope.submitDatas.predictNum);
            channel2Data.editor = scope.project.model.userName;
            channel2Data.signal = scope.submitDatas.currentSignal.signalID;
            channel2Data.name = scope.submitDatas.currentSignal.name;
            channel2Data.url = scope.dataUrl;
            channel2Data.desc = scope.submitDatas.predictText;
            str = Number(scope.submitDatas.predictNum);
            sus = scope.equipment.model.sampleUnits;
            su = '';
            for (_i = 0, _len = sus.length; _i < _len; _i++) {
              i = sus[_i];
              if (i.id === 'sustream') {
                su = i.value;
              }
            }
            return $.post("manualControl", {
              su: su,
              channel1: channel1,
              channel1data: str,
              channel2: "manual-describe",
              channel2data: channel2Data
            }).then(function(response) {
              console.log(response);
              if (response.result === 1 || response.data.result === 1) {
                _this.display('信息反馈成功!');
                scope.submitDatas.predictNum = 0;
                scope.submitDatas.predictText = '';
                return scope.hidemodal();
              } else {
                return _this.display('信息反馈失败!');
              }
            });
          }
        };
      })(this);
      window.addEventListener('resize', scope.resize);
      return scope.fullscreen = function(element) {
        var el, exit;
        if (!element) {
          return;
        }
        if (typeof element === 'string') {
          el = angular.element(element);
          element = el[0];
        }
        exit = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
        if (exit) {
          if (document.exitFullscreen) {
            return document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            return document.webkitExitFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else if (document.mozExitFullScreen) {
            return document.mozExitFullScreen();
          } else if (document.msExitFullscreen) {
            return document.msExitFullscreen();
          }
        } else {
          if (element.requestFullscreen) {
            return element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            return element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else if (element.mozRequestFullScreen) {
            return element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            return element.msRequestFullscreen();
          }
        }
      };
    };

    StreamVoiceCurveDirective.prototype.createOption = function(opts, index) {
      var color, i, option, series, title, visualMap;
      i = Number(index + 1);
      color = ['#00E7EE', '#4169E1'];
      title = ['时间(ms)', '频率(Hz)'];
      series = {
        name: opts.currentLegends['legend' + i],
        type: 'line',
        symbol: "none",
        lineStyle: {
          width: 1
        },
        smooth: true,
        data: opts['yData' + i]
      };
      visualMap = [
        {
          top: 10,
          left: 10,
          seriesIndex: 0,
          textStyle: {
            color: '#fff'
          },
          pieces: [
            {
              gt: opts.normalDatas[index][0],
              lte: opts.normalDatas[index][1],
              color: color[index]
            }
          ],
          outOfRange: {
            color: 'red'
          }
        }
      ];
      option = {
        title: {
          text: opts['title' + i],
          textStyle: {
            color: '#fff'
          },
          left: 'center',
          top: 0,
          subtext: '采集时间' + opts.subtext,
          subtextStyle: {
            color: 'rgba(156,165,193,1)',
            fontSize: 14,
            left: 'right',
            align: 'right',
            verticalAlign: 'top'
          }
        },
        tooltip: {
          show: true,
          trigger: "axis",
          axisPointer: {
            type: 'cross'
          }
        },
        legend: {
          show: true,
          orient: "horizontal",
          bottom: 30,
          textStyle: {
            fontSize: 14,
            color: "#FFFFFF"
          },
          data: opts.currentLegends['legend' + i]
        },
        grid: {
          right: 5
        },
        toolbox: {
          show: true,
          right: 0,
          feature: {
            dataZoom: {
              show: false
            },
            dataView: {
              show: false
            },
            magicType: {
              show: false,
              type: ['line', 'bar']
            },
            restore: {
              show: false
            },
            saveAsImage: {
              show: false
            }
          }
        },
        visualMap: visualMap,
        dataZoom: [
          {
            type: 'inside',
            realtime: true,
            start: opts.start,
            end: opts.end
          }, {
            show: true,
            realtime: true,
            type: 'slider',
            height: 20,
            borderColor: 'rgba(2,62,116,1)',
            dataBackground: {
              lineStyle: {
                width: 3,
                color: 'rgba(0,167,255,1)'
              },
              areaStyle: {
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: '#1A45A2'
                    }, {
                      offset: 1,
                      color: '#00E7EE'
                    }
                  ]
                }
              }
            },
            handleStyle: {
              color: 'rgba(0,167,255,1)'
            },
            textStyle: {
              fontSize: 14,
              color: "#FFFFFF"
            },
            fillerColor: "rgba(2,62,116,0.8)",
            bottom: 0
          }
        ],
        xAxis: {
          name: title[index],
          nameTextStyle: {
            color: 'rgba(156,165,193,1)'
          },
          data: opts.xData,
          type: 'category',
          boundaryGap: false,
          nameLocation: "middle",
          axisLine: {
            onZero: false,
            lineStyle: {
              color: "#204BAD"
            }
          },
          axisLabel: {
            show: false,
            textStyle: {
              color: 'rgba(156,165,193,1)'
            }
          }
        },
        yAxis: {
          name: '振幅(g)',
          nameLocation: 'middle',
          nameTextStyle: {
            color: 'rgba(156,165,193,1)',
            fontSize: 14,
            padding: [0, 0, 130, 0],
            align: 'left',
            verticalAlign: 'middle'
          },
          type: 'value',
          axisLine: {
            lineStyle: {
              color: "#204BAD"
            }
          },
          axisLabel: {
            textStyle: {
              color: "rgba(156,165,193,1)"
            }
          },
          splitLine: {
            show: false
          }
        },
        series: series
      };
      return option;
    };

    StreamVoiceCurveDirective.prototype.resize = function(scope) {
      return this.$timeout((function(_this) {
        return function() {
          var _ref, _ref1;
          if ((_ref = scope.echart1) != null) {
            _ref.resize();
          }
          return (_ref1 = scope.echart2) != null ? _ref1.resize() : void 0;
        };
      })(this), 0);
    };

    StreamVoiceCurveDirective.prototype.dispose = function(scope) {
      var _ref, _ref1;
      if ((_ref = scope.echart1) != null) {
        _ref.dispose();
      }
      scope.echart1 = null;
      if ((_ref1 = scope.echart2) != null) {
        _ref1.dispose();
      }
      scope.echart2 = null;
      scope.chartOpts = null;
      scope.chartDatas = null;
      return clearInterval(scope.interval1);
    };

    return StreamVoiceCurveDirective;

  })(base.BaseDirective);
  return exports = {
    StreamVoiceCurveDirective: StreamVoiceCurveDirective
  };
});
