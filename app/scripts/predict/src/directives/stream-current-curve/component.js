// Generated by IcedCoffeeScript 108.0.13

/*
* File: stream-current-curve-directive
* User: David
* Date: 2020/03/10
* Desc:
 */
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['../base-directive', 'text!./style.css', 'text!./view.html', 'underscore', "moment", "echarts"], function(base, css, view, _, moment, echarts) {
  var StreamCurrentCurveDirective, exports;
  StreamCurrentCurveDirective = (function(_super) {
    __extends(StreamCurrentCurveDirective, _super);

    function StreamCurrentCurveDirective($timeout, $window, $compile, $routeParams, commonService) {
      this.createOption = __bind(this.createOption, this);
      this.show = __bind(this.show, this);
      this.id = "stream-current-curve";
      StreamCurrentCurveDirective.__super__.constructor.call(this, $timeout, $window, $compile, $routeParams, commonService);
    }

    StreamCurrentCurveDirective.prototype.setScope = function() {};

    StreamCurrentCurveDirective.prototype.setCSS = function() {
      return css;
    };

    StreamCurrentCurveDirective.prototype.setTemplate = function() {
      return view;
    };

    StreamCurrentCurveDirective.prototype.show = function(scope, element, attrs) {
      var _ref, _ref1;
      scope.playFlag = false;
      scope.signalDataArr = [];
      scope.equipSubscription = {};
      scope.submitDatas = {
        currentSignal: '',
        predictNum: 0,
        predictText: ''
      };
      scope.currentLegends = [];
      scope.interval1 = null;
      scope.chartOpts = {
        yData1MinAndMax: [0, 0]
      };
      scope.chartDatas = {
        yDatas: []
      };
      scope.chartOpts.legends = [];
      scope.chartOpts.yDatas = [];
      scope.chartOpts.end = 10;
      scope.chartOpts.start = 0;
      scope.streamLegendList = [];
      scope.currentDisplayList = [];
      scope.currentMinAndMax = [[0, 0], [0, 0]];
      scope.abcSeriesList = [];
      scope.maxAndMins = {};
      scope.dataFlag = false;
      scope.getStreamSignalData = (function(_this) {
        return function() {
          var filter, strId, _ref;
          filter = {
            user: scope.project.model.user,
            project: scope.project.model.project,
            station: scope.equipment.model.station,
            equipment: scope.equipment.model.equipment,
            signal: scope.parameters.currentSignal + '-ttf'
          };
          strId = scope.equipment.key + "-" + filter.signal;
          if ((_ref = scope.equipSubscription[strId]) != null) {
            _ref.dispose();
          }
          return scope.equipSubscription[strId] = _this.commonService.signalLiveSession.subscribeValues(filter, function(err, signal) {
            var xhr;
            if (signal.message && signal.message.value) {
              scope.dataFlag = true;
              scope.collectTime = moment(signal.message.timestamp).format("YYYY-MM-DD HH:mm:ss");
              scope.chartOpts.subtext = scope.collectTime;
              scope.dataUrl = signal.message.value;
              scope.$root.loading = true;
              xhr = new XMLHttpRequest();
              xhr.open('get', scope.dataUrl, true);
              xhr.responseType = 'arraybuffer';
              xhr.onload = function(e) {
                var data, testStr, wb;
                if (xhr.status === 200) {
                  data = new Uint8Array(xhr.response);
                  wb = XLSX.read(data, {
                    type: 'array'
                  });
                  testStr = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
                  return scope.jsonToStringData(testStr);
                }
              };
              return xhr.send();
            }
          });
        };
      })(this);
      if (scope.parameters.streamFlag) {
        scope.getStreamSignalData();
      } else {
        if ((_ref = scope.echart1) != null) {
          _ref.dispose();
        }
        if ((_ref1 = scope.echart2) != null) {
          _ref1.dispose();
        }
        scope.echart1 = null;
        scope.echart2 = null;
      }
      scope.downLoadStream = (function(_this) {
        return function() {
          if (scope.dataUrl) {
            return window.open(scope.dataUrl, '_blank');
          } else {
            return _this.display("暂无数据，无法下载！");
          }
        };
      })(this);
      scope.InitChartOpt = (function(_this) {
        return function() {
          var myChart1, myChart2, option1, option2;
          myChart1 = element.find("#ss-chart1");
          myChart2 = element.find("#ss-chart2");
          scope.$root.loading = false;
          scope.echart1 = echarts.init(myChart1[0]);
          scope.echart2 = echarts.init(myChart2[0]);
          option1 = _this.createOption(scope.chartOpts, 0);
          option2 = _this.createOption(scope.chartOpts, 1);
          scope.echart1.setOption(option1);
          return scope.echart2.setOption(option2);
        };
      })(this);
      scope.originalStream = (function(_this) {
        return function() {
          _this.commonService.publishEventBus('old-new-stream-flag', 'old');
          scope.$applyAsync();
          return console.log(scope.parameters);
        };
      })(this);
      scope.chartShowAll = (function(_this) {
        return function() {
          var abcIndex, legendIndex;
          clearInterval(scope.interval1);
          scope.playFlag = false;
          if (scope.echart1 && scope.chartOpts && scope.chartDatas.xData) {
            abcIndex = Number(scope.chartOpts.currentAbcSeries.index + 1);
            legendIndex = Number(scope.chartOpts.currentLegends.index);
            scope.chartOpts.yData1 = scope.chartDatas['data' + abcIndex].yData1[legendIndex];
            scope.chartOpts.yData2 = scope.chartDatas['data' + abcIndex].yData2[legendIndex];
            return scope.reSetChartOpts(scope.chartOpts);
          }
        };
      })(this);
      scope.chartPlayPause = (function(_this) {
        return function() {
          var abcIndex, legendIndex;
          if (!scope.playFlag) {
            if (scope.echart1 && scope.chartOpts && scope.chartDatas.xData) {
              if (scope.chartOpts.yData1.length === scope.chartDatas.xData.length) {
                scope.chartOpts.yData1 = [];
                scope.chartOpts.yData2 = [];
              }
              scope.playFlag = true;
              abcIndex = Number(scope.chartOpts.currentAbcSeries.index + 1);
              legendIndex = Number(scope.chartOpts.currentLegends.index);
              return scope.interval1 = setInterval(function() {
                var i;
                if (scope.chartOpts.yData1.length < scope.chartDatas.xData.length) {
                  i = 0;
                  while (i < 2) {
                    scope.chartOpts.yData1.push(scope.chartDatas['data' + abcIndex].yData1[legendIndex][scope.chartOpts.yData1.length]);
                    scope.chartOpts.yData2.push(scope.chartDatas['data' + abcIndex].yData2[legendIndex][scope.chartOpts.yData2.length]);
                    i++;
                  }
                } else {
                  scope.chartOpts.yData1 = [];
                  scope.chartOpts.yData2 = [];
                }
                return scope.reSetChartOpts(scope.chartOpts);
              }, 1000);
            }
          } else {
            clearInterval(scope.interval1);
            return scope.playFlag = false;
          }
        };
      })(this);
      scope.jsonToStringData = (function(_this) {
        return function(data) {
          var i, item, j, k, keyData, minAndMax1, minAndMax2, minAndMax3, name, name1, name2, seriesSelect, signal, xData, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4;
          xData = [];
          scope.chartDatas.data1 = {
            yData1: [[], [], []],
            yData2: [[], [], []]
          };
          scope.chartDatas.data2 = {
            yData1: [[], [], []],
            yData2: [[], [], []]
          };
          scope.chartDatas.data3 = {
            yData1: [[], [], []],
            yData2: [[], [], []]
          };
          minAndMax1 = {
            yData1MinAndMax: [[], [], []],
            yData2MinAndMax: [[], [], []]
          };
          minAndMax2 = {
            yData1MinAndMax: [[], [], []],
            yData2MinAndMax: [[], [], []]
          };
          minAndMax3 = {
            yData1MinAndMax: [[], [], []],
            yData2MinAndMax: [[], [], []]
          };
          if (Array.isArray(data)) {
            signal = scope.parameters.currentSignal;
            scope.chartOpts.normalDatas = [[-20000000, 20000000], [0, 200]];
            keyData = data[0];
            for (j in keyData) {
              k = keyData[j];
              scope.chartOpts.legends.push(j);
            }
            if (scope.chartOpts.legends.length === 21) {
              scope.chartOpts.legends.pop();
              scope.chartOpts.legends.splice(6, 1);
              scope.chartOpts.legends.splice(12, 1);
              _ref2 = [0, 1, 2];
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                j = _ref2[_i];
                scope.streamLegendList.push([]);
                _ref3 = [0, 1, 2];
                for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                  i = _ref3[_j];
                  name1 = scope.chartOpts.legends[i + j * 6];
                  name2 = scope.chartOpts.legends[i + j * 6 + 3];
                  name = name1 + ',' + name2;
                  scope.streamLegendList[j].push({
                    legend1: name1,
                    legend2: name2,
                    name: name,
                    index: i,
                    optindex: j
                  });
                }
              }
            } else if (scope.chartOpts.legends.length === 7) {
              scope.chartOpts.legends.pop();
              _ref4 = [0, 1, 2];
              for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                i = _ref4[_k];
                name1 = scope.chartOpts.legends[i];
                name2 = scope.chartOpts.legends[i + 3];
                name = name1 + ',' + name2;
                scope.streamLegendList.push({
                  legend1: name1,
                  legend2: name2,
                  name: name,
                  index: i
                });
              }
            }
            if (signal === 's-data-7') {
              seriesSelect = ['A相电流', 'B相电流', 'C相电流'];
            } else {
              seriesSelect = ['X轴震动', 'Y轴震动', 'Z轴震动'];
            }
            scope.abcSeriesList = _.map(seriesSelect, function(d, i) {
              return {
                legend: d,
                name: d,
                index: i
              };
            });
            scope.currentDisplayList = scope.streamLegendList[0];
            scope.chartOpts.currentAbcSeries = scope.abcSeriesList[0];
            scope.chartOpts.currentLegends = scope.currentDisplayList[0];
            for (i = _l = 0, _len3 = data.length; _l < _len3; i = ++_l) {
              item = data[i];
              xData.push(i + 1);
              scope.chartDatas.data1.yData1[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[0]]));
              scope.chartDatas.data1.yData1[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[1]]));
              scope.chartDatas.data1.yData1[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[2]]));
              scope.chartDatas.data1.yData2[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[3]]));
              scope.chartDatas.data1.yData2[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[4]]));
              scope.chartDatas.data1.yData2[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[5]]));
              scope.chartDatas.data2.yData1[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[6]]));
              scope.chartDatas.data2.yData1[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[7]]));
              scope.chartDatas.data2.yData1[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[8]]));
              scope.chartDatas.data2.yData2[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[9]]));
              scope.chartDatas.data2.yData2[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[10]]));
              scope.chartDatas.data2.yData2[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[11]]));
              scope.chartDatas.data3.yData1[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[12]]));
              scope.chartDatas.data3.yData1[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[13]]));
              scope.chartDatas.data3.yData1[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[14]]));
              scope.chartDatas.data3.yData2[0].push(scope.checkIfNumber(item[scope.chartOpts.legends[15]]));
              scope.chartDatas.data3.yData2[1].push(scope.checkIfNumber(item[scope.chartOpts.legends[16]]));
              scope.chartDatas.data3.yData2[2].push(scope.checkIfNumber(item[scope.chartOpts.legends[17]]));
            }
            scope.chartOpts.xData = xData;
            scope.chartOpts.title1 = scope.parameters.currentName + '时域图';
            scope.chartOpts.title2 = scope.parameters.currentName + '频域图';
            scope.chartOpts.yData1 = scope.chartDatas.data1.yData1[0];
            scope.chartOpts.yData2 = scope.chartDatas.data1.yData2[0];
            scope.chartDatas.xData = xData;
            scope.InitChartOpt();
            minAndMax1.yData1MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.data1.yData1[0]), Math.max.apply(Math, scope.chartDatas.data1.yData1[0]));
            minAndMax1.yData1MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.data1.yData1[1]), Math.max.apply(Math, scope.chartDatas.data1.yData1[1]));
            minAndMax1.yData1MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.data1.yData1[2]), Math.max.apply(Math, scope.chartDatas.data1.yData1[2]));
            minAndMax1.yData2MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.data1.yData2[0]), Math.max.apply(Math, scope.chartDatas.data1.yData2[0]));
            minAndMax1.yData2MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.data1.yData2[1]), Math.max.apply(Math, scope.chartDatas.data1.yData2[1]));
            minAndMax1.yData2MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.data1.yData2[2]), Math.max.apply(Math, scope.chartDatas.data1.yData2[2]));
            minAndMax2.yData1MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.data2.yData1[0]), Math.max.apply(Math, scope.chartDatas.data2.yData1[0]));
            minAndMax2.yData1MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.data2.yData1[1]), Math.max.apply(Math, scope.chartDatas.data2.yData1[1]));
            minAndMax2.yData1MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.data2.yData1[2]), Math.max.apply(Math, scope.chartDatas.data2.yData1[2]));
            minAndMax2.yData2MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.data2.yData2[0]), Math.max.apply(Math, scope.chartDatas.data2.yData2[0]));
            minAndMax2.yData2MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.data2.yData2[1]), Math.max.apply(Math, scope.chartDatas.data2.yData2[1]));
            minAndMax2.yData2MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.data2.yData2[2]), Math.max.apply(Math, scope.chartDatas.data2.yData2[2]));
            minAndMax3.yData1MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.data3.yData1[0]), Math.max.apply(Math, scope.chartDatas.data3.yData1[0]));
            minAndMax3.yData1MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.data3.yData1[1]), Math.max.apply(Math, scope.chartDatas.data3.yData1[1]));
            minAndMax3.yData1MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.data3.yData1[2]), Math.max.apply(Math, scope.chartDatas.data3.yData1[2]));
            minAndMax3.yData2MinAndMax[0].push(Math.min.apply(Math, scope.chartDatas.data3.yData2[0]), Math.max.apply(Math, scope.chartDatas.data3.yData2[0]));
            minAndMax3.yData2MinAndMax[1].push(Math.min.apply(Math, scope.chartDatas.data3.yData2[1]), Math.max.apply(Math, scope.chartDatas.data3.yData2[1]));
            minAndMax3.yData2MinAndMax[2].push(Math.min.apply(Math, scope.chartDatas.data3.yData2[2]), Math.max.apply(Math, scope.chartDatas.data3.yData2[2]));
            scope.maxAndMins.minAndMax1 = minAndMax1;
            scope.maxAndMins.minAndMax2 = minAndMax2;
            scope.maxAndMins.minAndMax3 = minAndMax3;
            scope.currentMinAndMax[0] = minAndMax1.yData1MinAndMax[0];
            scope.currentMinAndMax[1] = minAndMax1.yData2MinAndMax[0];
            return scope.$applyAsync();
          }
        };
      })(this);
      scope.selectSeriesData = (function(_this) {
        return function(abc, index) {
          var abcIndex, legendIndex;
          clearInterval(scope.interval1);
          legendIndex = Number(scope.chartOpts.currentLegends.index);
          abcIndex = Number(index + 1);
          scope.currentDisplayList = scope.streamLegendList[index];
          scope.chartOpts.currentAbcSeries = scope.abcSeriesList[index];
          scope.chartOpts.currentLegends = scope.currentDisplayList[legendIndex];
          scope.chartOpts.yData1 = scope.chartDatas['data' + abcIndex].yData1[legendIndex];
          scope.chartOpts.yData2 = scope.chartDatas['data' + abcIndex].yData2[legendIndex];
          scope.currentMinAndMax[0] = scope.maxAndMins['minAndMax' + abcIndex].yData1MinAndMax[legendIndex];
          scope.currentMinAndMax[1] = scope.maxAndMins['minAndMax' + abcIndex].yData2MinAndMax[legendIndex];
          return scope.reSetChartOpts(scope.chartOpts);
        };
      })(this);
      scope.selectLegend = (function(_this) {
        return function(leg, index) {
          var abcIndex;
          clearInterval(scope.interval1);
          abcIndex = Number(scope.chartOpts.currentAbcSeries.index + 1);
          scope.chartOpts.currentLegends = scope.currentDisplayList[index];
          scope.chartOpts.yData1 = scope.chartDatas['data' + abcIndex].yData1[index];
          scope.chartOpts.yData2 = scope.chartDatas['data' + abcIndex].yData2[index];
          scope.currentMinAndMax[0] = scope.maxAndMins['minAndMax' + abcIndex].yData1MinAndMax[index];
          scope.currentMinAndMax[1] = scope.maxAndMins['minAndMax' + abcIndex].yData2MinAndMax[index];
          return scope.reSetChartOpts(scope.chartOpts);
        };
      })(this);
      scope.reSetChartOpts = (function(_this) {
        return function(opts) {
          var legend1, legend2, series1, series2;
          series1 = [];
          series2 = [];
          legend1 = opts.currentLegends.legend1;
          legend2 = opts.currentLegends.legend2;
          series1.push({
            name: legend1,
            data: opts.yData1
          });
          series2.push({
            name: legend2,
            data: opts.yData2
          });
          scope.echart1.setOption({
            legend: {
              data: legend1
            },
            series: series1
          });
          return scope.echart2.setOption({
            legend: {
              data: legend2
            },
            series: series2
          });
        };
      })(this);
      scope.fullscreen = function(element) {
        var el, exit;
        if (!element) {
          return;
        }
        if (typeof element === 'string') {
          el = angular.element(element);
          element = el[0];
        }
        exit = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
        if (exit) {
          if (document.exitFullscreen) {
            return document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            return document.webkitExitFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else if (document.mozExitFullScreen) {
            return document.mozExitFullScreen();
          } else if (document.msExitFullscreen) {
            return document.msExitFullscreen();
          }
        } else {
          if (element.requestFullscreen) {
            return element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            return element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else if (element.mozRequestFullScreen) {
            return element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            return element.msRequestFullscreen();
          }
        }
      };
      scope.checkIfNumber = (function(_this) {
        return function(val) {
          if (!isNaN(Number(val))) {
            return Number(val);
          } else {
            return 0;
          }
        };
      })(this);
      scope.hidemodal = function() {
        return $('#stream-predict-modal').modal('close');
      };
      scope.openModal = function() {
        return $('#stream-predict-modal').modal('open');
      };
      scope.compare = (function(_this) {
        return function() {
          return window.location.hash = "#/stream-compare/" + scope.project.model.user + "/" + scope.project.model.project;
        };
      })(this);
      scope.equipment.loadSignals(null, (function(_this) {
        return function(err, signals) {
          var sig, signalValue, _i, _len, _results;
          if (signals) {
            _results = [];
            for (_i = 0, _len = signals.length; _i < _len; _i++) {
              sig = signals[_i];
              if (sig.model.type === scope.equipment.model.type) {
                if (sig.model.template === "base-" + scope.equipment.model.type && sig.model.signal !== "device-flag" && sig.model.signal !== "device-health") {
                  signalValue = {};
                  signalValue.name = sig.model.name;
                  signalValue.signalID = sig.model.signal;
                  signalValue.passId = sig.model.expression.variables[0].value;
                  signalValue.check = false;
                  scope.signalDataArr.push(signalValue);
                  _results.push(scope.submitDatas.currentSignal = scope.signalDataArr[0]);
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        };
      })(this));
      scope.selectStreamSig = (function(_this) {
        return function(type, index) {
          return scope.submitDatas.currentSignal = type;
        };
      })(this);
      scope.submitMessage = (function(_this) {
        return function() {
          var channel1, channel2Data, i, str, su, sus, _i, _len;
          if (Number(scope.submitDatas.predictNum) > 100 || Number(scope.submitDatas.predictNum) < 0) {
            _this.display('预测值为0~100之间!');
          } else {
            channel2Data = {};
            channel1 = scope.submitDatas.currentSignal.passId.split('/')[1];
            channel2Data.mchannel = channel1;
            channel2Data.mvalue = Number(scope.submitDatas.predictNum);
            channel2Data.editor = scope.project.model.userName;
            channel2Data.signal = scope.submitDatas.currentSignal.signalID;
            channel2Data.name = scope.submitDatas.currentSignal.name;
            channel2Data.url = scope.dataUrl;
            channel2Data.desc = scope.submitDatas.predictText;
            str = Number(scope.submitDatas.predictNum);
            sus = scope.equipment.model.sampleUnits;
            su = '';
            for (_i = 0, _len = sus.length; _i < _len; _i++) {
              i = sus[_i];
              if (i.id === 'sustream') {
                su = i.value;
              }
            }
            return $.post("manualControl", {
              su: su,
              channel1: channel1,
              channel1data: str,
              channel2: "manual-describe",
              channel2data: channel2Data
            }).then(function(response) {
              console.log(response);
              if (response.result === 1 || response.data.result === 1) {
                _this.display('信息反馈成功!');
                scope.submitDatas.predictNum = 0;
                scope.submitDatas.predictText = '';
                return scope.hidemodal();
              } else {
                return _this.display('信息反馈失败!');
              }
            });
          }
        };
      })(this);
      return window.addEventListener('resize', scope.resize);
    };

    StreamCurrentCurveDirective.prototype.createOption = function(opts, index) {
      var color, colors, i, option, series, title, visualMap;
      i = Number(index + 1);
      colors = [['#1A45A2', '#00E7EE'], ['#90D78A', '#1CAA9E'], ['#F9722C', '#FF085C']];
      color = ['#00E7EE', '#4169E1'];
      title = ['时间(ms)', '频率(Hz)'];
      series = {
        name: opts.currentLegends['legend' + i],
        type: 'line',
        symbol: "none",
        lineStyle: {
          width: 1
        },
        smooth: true,
        data: opts['yData' + i]
      };
      visualMap = [
        {
          top: 10,
          left: 10,
          seriesIndex: 0,
          textStyle: {
            color: '#fff'
          },
          pieces: [
            {
              gt: opts.normalDatas[index][0],
              lte: opts.normalDatas[index][1],
              color: color[index]
            }
          ],
          outOfRange: {
            color: 'red'
          }
        }
      ];
      option = {
        title: {
          text: opts['title' + i],
          textStyle: {
            color: '#fff'
          },
          left: 'center',
          top: 0,
          subtext: '采集时间' + opts.subtext,
          subtextStyle: {
            color: 'rgba(156,165,193,1)',
            fontSize: 14
          }
        },
        tooltip: {
          show: true,
          trigger: "axis",
          axisPointer: {
            type: 'cross'
          }
        },
        legend: {
          show: true,
          orient: "horizontal",
          bottom: 30,
          textStyle: {
            fontSize: 14,
            color: "#FFFFFF"
          },
          data: opts.currentLegends['legend' + i]
        },
        grid: {
          right: 5
        },
        toolbox: {
          show: true,
          right: 0,
          feature: {
            dataZoom: {
              show: false
            },
            dataView: {
              show: false
            },
            magicType: {
              show: false,
              type: ['line', 'bar']
            },
            restore: {
              show: false
            },
            saveAsImage: {
              show: false
            }
          }
        },
        visualMap: visualMap,
        dataZoom: [
          {
            type: 'inside',
            realtime: true,
            start: opts.start,
            end: opts.end
          }, {
            show: true,
            realtime: true,
            type: 'slider',
            height: 20,
            borderColor: 'rgba(2,62,116,1)',
            dataBackground: {
              lineStyle: {
                width: 3,
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: '#1A45A2'
                    }, {
                      offset: 1,
                      color: '#00E7EE'
                    }
                  ]
                }
              },
              areaStyle: {
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: '#1A45A2'
                    }, {
                      offset: 1,
                      color: '#00E7EE'
                    }
                  ]
                }
              }
            },
            handleStyle: {
              color: 'rgba(0,167,255,1)'
            },
            textStyle: {
              fontSize: 14,
              color: "#FFFFFF"
            },
            fillerColor: "rgba(2,62,116,0.8)",
            bottom: 0
          }
        ],
        xAxis: {
          name: title[index],
          nameTextStyle: {
            color: 'rgba(156,165,193,1)'
          },
          data: opts.xData,
          type: 'category',
          boundaryGap: false,
          nameLocation: "middle",
          axisLine: {
            onZero: false,
            lineStyle: {
              color: "#204BAD"
            }
          },
          axisLabel: {
            show: false,
            textStyle: {
              color: "#fff"
            }
          }
        },
        yAxis: {
          name: '振幅(g)',
          nameLocation: 'middle',
          nameTextStyle: {
            color: 'rgba(156,165,193,1)',
            fontSize: 14,
            padding: [0, 0, 130, 0],
            align: 'left',
            verticalAlign: 'middle'
          },
          type: 'value',
          axisLine: {
            lineStyle: {
              color: "#204BAD"
            }
          },
          axisLabel: {
            textStyle: {
              color: "rgba(156,165,193,1)"
            }
          },
          splitLine: {
            show: false
          }
        },
        series: series
      };
      return option;
    };

    StreamCurrentCurveDirective.prototype.resize = function(scope) {
      return this.$timeout((function(_this) {
        return function() {
          var _ref, _ref1;
          if ((_ref = scope.echart1) != null) {
            _ref.resize();
          }
          return (_ref1 = scope.echart2) != null ? _ref1.resize() : void 0;
        };
      })(this), 0);
    };

    StreamCurrentCurveDirective.prototype.dispose = function(scope) {
      var key, value, _ref, _ref1, _ref2;
      _ref = scope.equipSubscription;
      for (key in _ref) {
        value = _ref[key];
        if (value != null) {
          value.dispose();
        }
      }
      if ((_ref1 = scope.echart1) != null) {
        _ref1.dispose();
      }
      scope.echart1 = null;
      if ((_ref2 = scope.echart2) != null) {
        _ref2.dispose();
      }
      scope.echart2 = null;
      scope.chartOpts = null;
      scope.chartDatas = null;
      return clearInterval(scope.interval1);
    };

    return StreamCurrentCurveDirective;

  })(base.BaseDirective);
  return exports = {
    StreamCurrentCurveDirective: StreamCurrentCurveDirective
  };
});
