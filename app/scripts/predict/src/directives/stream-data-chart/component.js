// Generated by IcedCoffeeScript 108.0.13

/*
* File: stream-data-chart-directive
* User: David
* Date: 2020/01/02
* Desc:
 */
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['../base-directive', 'text!./style.css', 'text!./view.html', 'underscore', "moment", "echarts"], function(base, css, view, _, moment, echarts) {
  var StreamDataChartDirective, exports;
  StreamDataChartDirective = (function(_super) {
    __extends(StreamDataChartDirective, _super);

    function StreamDataChartDirective($timeout, $window, $compile, $routeParams, commonService) {
      this.show = __bind(this.show, this);
      this.id = "stream-data-chart";
      StreamDataChartDirective.__super__.constructor.call(this, $timeout, $window, $compile, $routeParams, commonService);
    }

    StreamDataChartDirective.prototype.setScope = function() {};

    StreamDataChartDirective.prototype.setCSS = function() {
      return css;
    };

    StreamDataChartDirective.prototype.setTemplate = function() {
      return view;
    };

    StreamDataChartDirective.prototype.show = function(scope, element, attrs) {
      var chartelement, cleanData, createOption, currentSignal, getTodayData, severityType, subscribeTodayValue;
      scope.chartValues = [];
      scope.currentSignalName = "信号选择";
      if (!scope.mode) {
        scope.mode = "now";
      }
      scope.mychart = null;
      chartelement = element.find('.stream-line');
      scope.mychart = echarts.init(chartelement[0]);
      currentSignal = [];
      scope.allStreamsignals = [];
      scope.streamSignalList = [];
      scope.streamDatas = [];
      scope.streamDatas1 = [];
      scope.streamDatas2 = [];
      scope.streamDatas3 = [];
      scope.equipSubscription = {};
      subscribeTodayValue = null;
      severityType = {};
      _.map(scope.project.dictionary.eventseverities.items, (function(_this) {
        return function(d) {
          return severityType[d.model.severity] = d.model.color;
        };
      })(this));
      scope.selectSignal = (function(_this) {
        return function(signal, index) {
          var item, _i, _len, _ref;
          _ref = scope.streamSignalList;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            if (item.signal === currentSignal[0]) {
              item.check = false;
            }
          }
          currentSignal[0] = signal.signal;
          scope.currentSignalName = signal.name;
          scope.streamSignalList[index].check = true;
          return getTodayData();
        };
      })(this);
      cleanData = (function(_this) {
        return function() {
          scope.chartValues = [];
          return scope.streamSignalList = [];
        };
      })(this);
      getTodayData = (function(_this) {
        return function() {
          var filter, strId, _ref;
          scope.urls = [];
          filter = {
            user: scope.project.model.user,
            project: scope.project.model.project,
            station: scope.equipment.model.station,
            equipment: scope.equipment.model.equipment,
            signal: currentSignal[0]
          };
          strId = scope.equipment.key + "-" + currentSignal[0];
          if ((_ref = scope.equipSubscription[strId]) != null) {
            _ref.dispose();
          }
          return scope.equipSubscription[strId] = _this.commonService.signalLiveSession.subscribeValues(filter, function(err, signal) {
            var dname, item, str, subname, _i, _len;
            scope.urls = [];
            if (signal.message && signal.message.value) {
              str = signal.message.value.split(',');
              for (_i = 0, _len = str.length; _i < _len; _i++) {
                item = str[_i];
                scope.urls.push(item);
              }
              console.log(scope.urls);
              if (scope.urls.length === 1) {
                dname = '';
                return $.get(scope.urls[0], null, function(data) {
                  var j, strs, _j, _len1, _ref1;
                  strs = data.split("\n");
                  strs.pop();
                  _ref1 = scope.streamSignalList;
                  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                    j = _ref1[_j];
                    if (j.signal === signal.message.signal) {
                      dname = j.name;
                    }
                  }
                  scope.streamDatas = _.map(strs, function(d, i) {
                    return {
                      index: i,
                      name: signal.message.signal,
                      type: "line",
                      category: dname,
                      key: i,
                      value: Number(d),
                      severity: 1
                    };
                  });
                  return createOption(scope.streamDatas);
                });
              } else if (scope.urls.length === 3) {
                dname = '';
                subname = [];
                return $.get(scope.urls[0], null, function(data1) {
                  var j, strs, _j, _len1, _ref1;
                  strs = data1.split("\n");
                  strs.pop();
                  _ref1 = scope.streamSignalList;
                  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                    j = _ref1[_j];
                    if (j.signal === signal.message.signal) {
                      dname = j.name;
                      subname = j.subname.split(',');
                    }
                  }
                  scope.streamDatas1 = _.map(strs, function(d, i) {
                    return {
                      index: i,
                      name: signal.message.signal + '-1',
                      type: "line",
                      category: subname[0],
                      key: i,
                      value: Number(d),
                      severity: 1,
                      mainname: dname
                    };
                  });
                  return $.get(scope.urls[1], null, function(data2) {
                    var _k, _len2, _ref2;
                    strs = data2.split("\n");
                    strs.pop();
                    _ref2 = scope.streamSignalList;
                    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                      j = _ref2[_k];
                      if (j.signal === signal.message.signal) {
                        dname = j.name;
                      }
                    }
                    scope.streamDatas2 = _.map(strs, function(d, i) {
                      return {
                        index: i,
                        name: signal.message.signal + '-2',
                        type: "line",
                        category: subname[1],
                        key: i,
                        value: Number(d),
                        severity: 1,
                        mainname: dname
                      };
                    });
                    return $.get(scope.urls[2], null, function(data3) {
                      var _l, _len3, _ref3;
                      strs = data3.split("\n");
                      strs.pop();
                      _ref3 = scope.streamSignalList;
                      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                        j = _ref3[_l];
                        if (j.signal === signal.message.signal) {
                          dname = j.name;
                        }
                      }
                      scope.streamDatas3 = _.map(strs, function(d, i) {
                        return {
                          index: i,
                          name: signal.message.signal + '-3',
                          type: "line",
                          category: subname[2],
                          key: i,
                          value: Number(d),
                          severity: 1,
                          mainname: dname
                        };
                      });
                      scope.streamDatas1 = scope.streamDatas1.concat(scope.streamDatas2);
                      scope.streamDatas = scope.streamDatas1.concat(scope.streamDatas3);
                      return createOption(scope.streamDatas);
                    });
                  });
                });
              }
            }
          });
        };
      })(this);
      createOption = (function(_this) {
        return function(data) {
          var d, i, index, legendData, option, series, seriesData, type, value, values, xAxisData, yNameData, _i, _j, _legendData, _len, _len1;
          values = _.sortBy(_.sortBy(data, 'index'), 'name');
          if (!type) {
            type = 'line';
          }
          legendData = _.uniq(_.pluck(values, 'name'));
          xAxisData = _.uniq(_.pluck(values, 'key'));
          yNameData = _.uniq(_.pluck(values, 'category'));
          if (_.isEmpty(yNameData)) {
            yNameData = [''];
          }
          seriesData = [];
          for (index = _i = 0, _len = legendData.length; _i < _len; index = ++_i) {
            value = legendData[index];
            data = {
              name: value,
              data: _.pluck(_.where(values, {
                name: value,
                category: yNameData[index]
              }), 'value'),
              yAxisIndex: index
            };
            seriesData.push(data);
          }
          series = [
            {
              name: '',
              type: 'line',
              symbol: "none",
              smooth: true,
              data: [],
              lineStyle: {
                normal: {
                  color: {
                    type: 'linear',
                    x: 0,
                    y: 0,
                    x2: 0,
                    y2: 1,
                    colorStops: [
                      {
                        offset: 0,
                        color: '#1A45A2'
                      }, {
                        offset: 1,
                        color: '#00E7EE'
                      }
                    ]
                  }
                }
              }
            }, {
              name: '',
              type: 'line',
              smooth: true,
              symbol: "none",
              data: [],
              lineStyle: {
                normal: {
                  color: {
                    type: 'linear',
                    x: 0,
                    y: 0,
                    x2: 0,
                    y2: 1,
                    colorStops: [
                      {
                        offset: 0,
                        color: '#90D78A'
                      }, {
                        offset: 1,
                        color: '#1CAA9E'
                      }
                    ]
                  }
                }
              }
            }, {
              name: '',
              type: 'line',
              smooth: true,
              symbol: "none",
              data: [],
              lineStyle: {
                normal: {
                  color: {
                    type: 'linear',
                    x: 0,
                    y: 0,
                    x2: 0,
                    y2: 1,
                    colorStops: [
                      {
                        offset: 0,
                        color: '#F9722C'
                      }, {
                        offset: 1,
                        color: '#FF085C'
                      }
                    ]
                  }
                }
              }
            }
          ];
          for (i = _j = 0, _len1 = seriesData.length; _j < _len1; i = ++_j) {
            d = seriesData[i];
            series[i].name = yNameData[i];
            series[i].data = d.data;
            if (xAxisData.length < (series[i].data.length - 1)) {
              series[i].data.slice(0, series[i].data.length - 1);
            }
          }
          _legendData = _.map(legendData, function(d, i) {
            return {
              name: yNameData[i],
              icon: "image://" + _this.getComponentPath('image/color' + (i + 1) + '.svg')
            };
          });
          option = {
            tooltip: {
              show: true,
              trigger: "axis",
              axisPointer: {
                type: 'cross'
              }
            },
            legend: {
              show: true,
              orient: "horizontal",
              right: "10%",
              textStyle: {
                fontSize: 14,
                color: "#FFFFFF"
              },
              data: _legendData
            },
            toolbox: {
              show: true,
              right: 20,
              feature: {
                dataZoom: {
                  show: false
                },
                dataView: {
                  show: false
                },
                magicType: {
                  type: ['line', 'bar']
                },
                restore: {
                  show: false
                },
                saveAsImage: {
                  show: false
                }
              }
            },
            dataZoom: [
              {
                show: true,
                realtime: true,
                type: 'slider',
                dataBackground: {
                  lineStyle: {
                    width: 3,
                    color: 'rgb(9,175,211)'
                  }
                },
                textStyle: {
                  fontSize: 14,
                  color: "#FFFFFF"
                },
                fillerColor: "rgba(167,183,204,0.4)",
                start: 31,
                end: 32,
                xAxisIndex: [0]
              }, {
                type: 'inside',
                realtime: true,
                start: 31,
                end: 32,
                xAxisIndex: [0]
              }
            ],
            xAxis: [
              {
                show: false,
                data: xAxisData,
                boundaryGap: false,
                nameLocation: "middle",
                axisLine: {
                  lineStyle: {
                    color: "#204BAD"
                  }
                }
              }
            ],
            yAxis: [
              {
                type: 'value',
                axisLine: {
                  lineStyle: {
                    color: "#204BAD"
                  }
                },
                axisLabel: {
                  textStyle: {
                    color: "#A2CAF8"
                  }
                },
                splitLine: {
                  lineStyle: {
                    color: ["#204BAD"]
                  }
                }
              }
            ],
            series: series.slice(0, seriesData.length)
          };
          scope.mychart.clear();
          return scope.mychart.setOption(option);
        };
      })(this);
      return scope.equipment.loadSignals(null, (function(_this) {
        return function(err, signallists) {
          var item, _i, _len;
          for (_i = 0, _len = signallists.length; _i < _len; _i++) {
            item = signallists[_i];
            if (item.model.group === "stream") {
              scope.allStreamsignals.push(item);
            }
          }
          scope.streamSignalList = _.map(scope.allStreamsignals, function(d, i) {
            return {
              signal: d.model.signal,
              name: d.model.name,
              subname: d.model.desc,
              check: i === 0 ? true : false
            };
          });
          currentSignal = [scope.streamSignalList[0].signal];
          scope.currentSignalName = scope.streamSignalList[0].name;
          return getTodayData();
        };
      })(this), true);
    };

    StreamDataChartDirective.prototype.resize = function(scope) {
      return this.$timeout((function(_this) {
        return function() {
          var _ref;
          return (_ref = scope.mychart) != null ? _ref.resize() : void 0;
        };
      })(this), 0);
    };

    StreamDataChartDirective.prototype.dispose = function(scope) {
      var _ref, _ref1;
      if ((_ref = scope.timeSubscribe) != null) {
        _ref.dispose();
      }
      return (_ref1 = scope.mychart) != null ? _ref1.dispose() : void 0;
    };

    return StreamDataChartDirective;

  })(base.BaseDirective);
  return exports = {
    StreamDataChartDirective: StreamDataChartDirective
  };
});
