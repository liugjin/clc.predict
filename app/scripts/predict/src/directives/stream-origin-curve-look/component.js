// Generated by IcedCoffeeScript 108.0.13

/*
* File: stream-origin-curve-look-directive
* User: David
* Date: 2020/03/31
* Desc:
 */
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['../base-directive', 'text!./style.css', 'text!./view.html', 'underscore', "moment", "echarts"], function(base, css, view, _, moment, echarts) {
  var StreamOriginCurveLookDirective, exports;
  StreamOriginCurveLookDirective = (function(_super) {
    __extends(StreamOriginCurveLookDirective, _super);

    function StreamOriginCurveLookDirective($timeout, $window, $compile, $routeParams, commonService) {
      this.show = __bind(this.show, this);
      this.id = "stream-origin-curve-look";
      StreamOriginCurveLookDirective.__super__.constructor.call(this, $timeout, $window, $compile, $routeParams, commonService);
    }

    StreamOriginCurveLookDirective.prototype.setScope = function() {};

    StreamOriginCurveLookDirective.prototype.setCSS = function() {
      return css;
    };

    StreamOriginCurveLookDirective.prototype.setTemplate = function() {
      return view;
    };

    StreamOriginCurveLookDirective.prototype.show = function(scope, element, attrs) {
      var chartelement, createOption, currentSignal, getStreamSignalData, url, _ref;
      scope.playFlag = false;
      scope.interval1 = null;
      currentSignal = scope.parameters.streamSignal;
      scope.chartOpts = {};
      scope.chartDatas = {};
      scope.equipSubscription = {};
      scope.chartOpts.legends = [];
      scope.chartOpts.yDatas = [];
      scope.chartOpts.end = 2;
      scope.chartOpts.start = 0;
      scope.currentMinAndMax = [0, 0];
      scope.chartOpts.title = scope.parameters.signalName + '采集数据图';
      url = scope.parameters.value;
      getStreamSignalData = (function(_this) {
        return function() {
          if (currentSignal === 's-data-7') {
            scope.legendList = ['A相电流', 'B相电流', 'C相电流'];
          } else if (currentSignal === 's-data-5' || currentSignal === 's-data-6') {
            scope.legendList = ['X轴震动', 'Y轴震动', 'Z轴震动'];
          } else {
            scope.legendList = [scope.parameters.signalName];
          }
          scope.chartOpts.legends = scope.legendList;
          scope.chartDatas.xData = [];
          scope.collectTime = moment(scope.parameters.sampleTime).format("YYYY-MM-DD HH:mm:ss");
          scope.chartOpts.subtext = scope.collectTime;
          scope.urls = url.split(',');
          if (scope.urls.length === 1) {
            scope.chartDatas.yData = [[]];
            return $.get(scope.urls[0], null, function(data) {
              var i, index, j, strs, _i, _len;
              strs = data.split("\n");
              strs.pop();
              for (j = _i = 0, _len = strs.length; _i < _len; j = ++_i) {
                i = strs[j];
                index = j + 1;
                scope.chartDatas.xData.push(index);
                scope.chartDatas.yData[0].push(Number(i));
              }
              scope.chartOpts.yData = scope.chartDatas.yData;
              scope.chartOpts.xData = scope.chartDatas.xData;
              scope.calcMinAndMax(scope.chartDatas.yData);
              return createOption(scope.chartOpts);
            });
          } else if (scope.urls.length === 3) {
            scope.chartDatas.yData = [[], [], []];
            return $.get(scope.urls[0], null, function(data1) {
              var i, index, j, strs, _i, _len;
              strs = data1.split("\n");
              strs.pop();
              for (j = _i = 0, _len = strs.length; _i < _len; j = ++_i) {
                i = strs[j];
                index = j + 1;
                scope.chartDatas.xData.push(index);
                scope.chartDatas.yData[0].push(Number(i));
              }
              return $.get(scope.urls[1], null, function(data2) {
                var _j, _len1;
                strs = data2.split("\n");
                strs.pop();
                for (_j = 0, _len1 = strs.length; _j < _len1; _j++) {
                  j = strs[_j];
                  scope.chartDatas.yData[1].push(Number(j));
                }
                return $.get(scope.urls[2], null, function(data3) {
                  var k, _k, _len2;
                  strs = data3.split("\n");
                  strs.pop();
                  for (_k = 0, _len2 = strs.length; _k < _len2; _k++) {
                    k = strs[_k];
                    scope.chartDatas.yData[2].push(Number(k));
                  }
                  scope.chartOpts.yData = scope.chartDatas.yData;
                  scope.chartOpts.xData = scope.chartDatas.xData;
                  scope.calcMinAndMax(scope.chartDatas.yData);
                  return createOption(scope.chartOpts);
                });
              });
            });
          }
        };
      })(this);
      if (scope.parameters.clickFlag) {

      } else {
        if ((_ref = scope.mychart) != null) {
          _ref.dispose();
        }
        scope.mychart = null;
        chartelement = element.find('#ss-origin-chart');
        scope.mychart = echarts.init(chartelement[0]);
        getStreamSignalData();
      }
      scope.chartShowAll = (function(_this) {
        return function() {
          clearInterval(scope.interval1);
          scope.playFlag = false;
          if (scope.mychart && scope.chartOpts && scope.chartDatas.xData) {
            scope.chartOpts.yData = scope.chartDatas.yData;
            return scope.reSetChartOpts(scope.chartOpts);
          }
        };
      })(this);
      scope.chartPlayPause = (function(_this) {
        return function() {
          if (!scope.playFlag) {
            if (scope.mychart && scope.chartOpts && scope.chartDatas.xData) {
              if (scope.chartOpts.yData[0].length === scope.chartDatas.xData.length) {
                if (scope.chartOpts.legends.length === 3) {
                  scope.chartOpts.yData = [[], [], []];
                } else {
                  scope.chartOpts.yData = [[]];
                }
              }
              scope.playFlag = true;
              return scope.interval1 = setInterval(function() {
                var i;
                if (scope.chartOpts.yData[0].length < scope.chartDatas.xData.length) {
                  i = 0;
                  while (i < 4) {
                    if (scope.chartOpts.legends.length === 3) {
                      scope.chartOpts.yData[0].push(scope.chartDatas.yData[0][scope.chartOpts.yData[0].length]);
                      scope.chartOpts.yData[1].push(scope.chartDatas.yData[1][scope.chartOpts.yData[1].length]);
                      scope.chartOpts.yData[2].push(scope.chartDatas.yData[2][scope.chartOpts.yData[2].length]);
                    } else {
                      scope.chartOpts.yData[0].push(scope.chartDatas.yData[0][scope.chartOpts.yData[0].length]);
                    }
                    i++;
                  }
                } else {
                  scope.chartOpts.yData = [[]];
                }
                return scope.reSetChartOpts(scope.chartOpts);
              }, 1000);
            }
          } else {
            clearInterval(scope.interval1);
            return scope.playFlag = false;
          }
        };
      })(this);
      scope.reSetChartOpts = (function(_this) {
        return function(opts) {
          var index, item, series1, _i, _len, _ref1;
          series1 = [];
          _ref1 = opts.yData;
          for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
            item = _ref1[index];
            series1.push({
              data: item
            });
          }
          return scope.mychart.setOption({
            series: series1
          });
        };
      })(this);
      scope.checkIfNumber = (function(_this) {
        return function(val) {
          if (!isNaN(Number(val))) {
            return Number(val);
          } else {
            return 0;
          }
        };
      })(this);
      scope.calcMinAndMax = (function(_this) {
        return function(data) {
          var i, index, item, j, k, newData, yDataMinAndMax, _i, _j, _k, _len, _len1, _len2;
          yDataMinAndMax = [];
          newData = [];
          for (j = _i = 0, _len = data.length; _i < _len; j = ++_i) {
            i = data[j];
            newData.push([]);
            for (_j = 0, _len1 = i.length; _j < _len1; _j++) {
              k = i[_j];
              newData[j].push(scope.checkIfNumber(k));
            }
          }
          if (data.length === 3) {
            for (index = _k = 0, _len2 = newData.length; _k < _len2; index = ++_k) {
              item = newData[index];
              yDataMinAndMax.push(Math.min.apply(Math, item), Math.max.apply(Math, item));
            }
            scope.currentMinAndMax = [Math.min.apply(Math, yDataMinAndMax), Math.max.apply(Math, yDataMinAndMax)];
          } else {
            yDataMinAndMax.push(Math.min.apply(Math, newData[0]), Math.max.apply(Math, newData[0]));
            scope.currentMinAndMax = yDataMinAndMax;
          }
          return scope.$applyAsync();
        };
      })(this);
      return createOption = (function(_this) {
        return function(opts) {
          var colors, index, item, option, series, _i, _legendData, _len, _ref1;
          colors = [['#1A45A2', '#00E7EE'], ['#90D78A', '#1CAA9E'], ['#F9722C', '#FF085C']];
          series = [];
          console.log(opts);
          _ref1 = opts.yData;
          for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
            item = _ref1[index];
            series.push({
              name: opts.legends[index],
              type: 'line',
              symbol: "none",
              smooth: true,
              data: item,
              lineStyle: {
                width: 2,
                color: {
                  type: 'linear',
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: [
                    {
                      offset: 0,
                      color: colors[index][0]
                    }, {
                      offset: 1,
                      color: colors[index][1]
                    }
                  ]
                }
              }
            });
          }
          _legendData = _.map(opts.legends, function(d, i) {
            return {
              name: d,
              icon: "image://" + _this.getComponentPath('image/color' + (i + 1) + '.svg')
            };
          });
          option = {
            title: {
              text: opts.title,
              textStyle: {
                color: '#fff'
              },
              left: 'center',
              top: 0,
              subtext: '采集时间' + opts.subtext,
              subtextStyle: {
                color: 'rgba(156,165,193,1)',
                fontSize: 14
              }
            },
            tooltip: {
              show: true,
              trigger: "axis",
              axisPointer: {
                type: 'cross'
              }
            },
            legend: {
              show: true,
              right: '2%',
              orient: "horizontal",
              textStyle: {
                fontSize: 14,
                color: "#FFFFFF"
              },
              data: _legendData
            },
            grid: {
              right: 20
            },
            toolbox: {
              show: true,
              right: 20,
              feature: {
                dataZoom: {
                  show: false
                },
                dataView: {
                  show: false
                },
                magicType: {
                  show: false
                },
                restore: {
                  show: false
                },
                saveAsImage: {
                  show: false
                }
              }
            },
            dataZoom: [
              {
                type: 'inside',
                realtime: true,
                start: opts.start,
                end: opts.end
              }, {
                show: true,
                realtime: true,
                type: 'slider',
                height: 20,
                borderColor: 'rgba(2,62,116,1)',
                dataBackground: {
                  lineStyle: {
                    width: 3,
                    color: {
                      type: 'linear',
                      x: 0,
                      y: 0,
                      x2: 0,
                      y2: 1,
                      colorStops: [
                        {
                          offset: 0,
                          color: '#1A45A2'
                        }, {
                          offset: 1,
                          color: '#00E7EE'
                        }
                      ]
                    }
                  },
                  areaStyle: {
                    color: {
                      type: 'linear',
                      x: 0,
                      y: 0,
                      x2: 0,
                      y2: 1,
                      colorStops: [
                        {
                          offset: 0,
                          color: '#1A45A2'
                        }, {
                          offset: 1,
                          color: '#00E7EE'
                        }
                      ]
                    }
                  }
                },
                handleStyle: {
                  color: 'rgba(0,167,255,1)'
                },
                textStyle: {
                  fontSize: 14,
                  color: "#FFFFFF"
                },
                fillerColor: "rgba(2,62,116,0.8)",
                bottom: 0
              }
            ],
            xAxis: {
              show: false,
              nameTextStyle: {
                color: 'rgba(156,165,193,1)'
              },
              data: opts.xData,
              type: 'category',
              boundaryGap: false,
              nameLocation: "middle",
              axisLine: {
                onZero: false,
                lineStyle: {
                  color: "#204BAD"
                }
              },
              axisLabel: {
                show: false,
                textStyle: {
                  color: 'rgba(156,165,193,1)'
                }
              }
            },
            yAxis: {
              type: 'value',
              axisLine: {
                lineStyle: {
                  color: "#204BAD"
                }
              },
              axisLabel: {
                textStyle: {
                  color: 'rgba(156,165,193,1)'
                }
              },
              splitLine: {
                lineStyle: {
                  color: ["#204BAD"]
                }
              }
            },
            series: series
          };
          return scope.mychart.setOption(option);
        };
      })(this);
    };

    StreamOriginCurveLookDirective.prototype.resize = function(scope) {
      return this.$timeout((function(_this) {
        return function() {
          var _ref;
          return (_ref = scope.mychart) != null ? _ref.resize() : void 0;
        };
      })(this), 0);
    };

    StreamOriginCurveLookDirective.prototype.dispose = function(scope) {
      var _ref;
      if ((_ref = scope.mychart) != null) {
        _ref.dispose();
      }
      scope.mychart = null;
      scope.chartOpts = null;
      scope.chartDatas = null;
      return clearInterval(scope.interval1);
    };

    return StreamOriginCurveLookDirective;

  })(base.BaseDirective);
  return exports = {
    StreamOriginCurveLookDirective: StreamOriginCurveLookDirective
  };
});
